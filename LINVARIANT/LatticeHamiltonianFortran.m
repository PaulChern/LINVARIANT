BeginPackage["LINVARIANT`LatticeHamiltonianFortran`",{"LINVARIANT`Structure`","LINVARIANT`GroupTheory`","LINVARIANT`Fortran`", "LINVARIANT`MathematicaPlus`"}]

(*--------- Load, Save and Modify Crystal Structure Libraries ------------*)
FortranLatticeTikTok         ::usage "FortranLatticeTikTok[]"
FortranLatticeMCStep         ::usage "FortranLatticeMCStep[]"
FortranLatticePTSwap         ::usage "FortranLatticePTSwap[]"
FortranGetInitConfig         ::usage "FortranGetInitConfig[]"
FortranEwaldMatrix           ::usage "FortranEwaldMatrix[]"
FortranDeltaHEwald           ::usage "FortranDeltaHEwald[]"
FortranEOnSiteEwald          ::usage "FortranEOnSiteEwald[]"
FortranGetEwaldField         ::usage "FortranGetEwaldField[]"
FortranUpdateEwaldField      ::usage "FortranUpdateEwaldField[]"
FortranGetEwaldForces        ::usage "FortranGetEwaldForces[]"
HeadTailDeltaH               ::usage "HeadTailDeltaH[FunctionName, ReturnVar, FieldDim, nn]"
HeadTailForces               ::usage "HeadTailForces[FunctionName, ReturnVar, FieldDim, nn]"
HeadTailHessianOnSite        ::usage "HeadTailHessianOnSite[FunctionName, ReturnVar, FieldDim, nn]"
HeadTailEOnSite              ::usage "HeadTailEOnSite[FunctionName, ReturnVar, FieldDim, nn]"
WriteLatticeModelF90         ::usage "WriteLatticeModelF90[F90dir, FuncName, FuncType, InvariantList, MMAVars, MMA2F90Vars]"
(*--------- Plot and Manipulate Crystal Structures -------------------- ----------------*)

(*--------- Point and Space Group Information ---------------------------*)

(*--------------------------------------------------*)
(*-------------------------- Internal --------------*)
(*--------------------------------------------------*)

(*--------------------------- Options ----------------------------*)

(*--------------------------- external Modules -------------------*)

Begin["`Private`"]

(*--------------------------- Modules ----------------------------*)
FortranLatticeTikTok[OptionsPattern[{"AllSites"->True}]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = Join[
       {{"Subroutine TikTok(Fields, dFieldsdt, e0ij, de0ijdt, T0, gm)"},
        {Fint[1]},
        {Fint[1] <> "Use omp_lib"},
        {Fint[1] <> "Use LINVARIANT"},
        {Fint[1] <> "Use Constants"},
        {Fint[1] <> "Use Inputs"},
        {Fint[1]},
        {Fint[1] <> "Implicit none"},
        {Fint[1] <> "Real*8,  Intent(in)    :: T0"},
        {Fint[1] <> "Real*8,  Intent(inout) :: gm"},
        {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: dFieldsdt(FieldDim, NumField, NGridx, NGridy, NGridz)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: de0ijdt(3,3)"},
        {Fint[1] <> "Real*8                 :: Fields0(FieldDim, NumField, NGridx, NGridy, NGridz)"},
        {Fint[1] <> "Real*8                 :: e0ij0(3,3)"}},
       If[OptionValue["AllSites"], {{Fint[1] <> "Real*8                 :: Forces(FieldDim,NumField,NGridx,NGridy,NGridz)"}}, 
                                   {{Fint[1] <> "Real*8                 :: Forces(Max(FieldDim, 6),NumField+1)"}}],
       {{Fint[1] <> "Integer                :: i, ifield, fi, ix, iy, iz"},
        {Fint[1]},
        {Fint[1] <> "Fields0 = Fields"},
        {Fint[1] <> "e0ij0 = e0ij"},
        {Fint[1]}},
       If[OptionValue["AllSites"], 
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[2] <> "Forces = GetEwaldForces(Fields0) &"},
          {Fint[3] <> "+ GetForces(Fields0, e0ij0)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "Forces = GetForces(Fields0, e0ij0)"},
          {Fint[1] <> "end if"},
          {Fint[1] <> "Forces(:,1,:,:,:) = Forces(:,1,:,:,:)/mass(1)/mpme"},
          {Fint[1] <> "Forces(:,2,:,:,:) = Forces(:,2,:,:,:)/mass(2)/mpme"},
          {Fint[1] <> "Forces(:,3,:,:,:) = Forces(:,3,:,:,:)/mass(3)/mpme"},
          {Fint[1] <> "Forces(:,4,:,:,:) = Forces(:,4,:,:,:)/mass(4)/mpme"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1] <> "do iz = 1, NGridz"},
          {Fint[1] <> "do iy = 1, NGridy"},
          {Fint[1] <> "do ix = 1, NGridx"},
          {Fint[2] <> "! v(t+dt/2)"},
          {Fint[2] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)=dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)&"},
          {Fint[3] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField,ix,iy,iz)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[2] <> "! r(t+dt)"},
          {Fint[2] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz)=&"},
          {Fint[3] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz)+dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"}},
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[2] <> "do iz = 1, NGridz"},
          {Fint[2] <> "do iy = 1, NGridy"},
          {Fint[2] <> "do ix = 1, NGridx"},
          {Fint[3] <> "Forces = GetEwaldForces(ix,iy,iz,Fields0) &"},
          {Fint[4] <> "+ GetForces(ix,iy,iz,Fields0,e0ij0)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "! v(t+dt/2)"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[3] <> "! r(t+dt)"},
          {Fint[3] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz) = &"},
          {Fint[4] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz) + dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "else"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[2] <> "do iz = 1, NGridz"},
          {Fint[2] <> "do iy = 1, NGridy"},
          {Fint[2] <> "do ix = 1, NGridx"},
          {Fint[3] <> "Forces = GetForces(ix,iy,iz,Fields0,e0ij0)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "! v(t+dt/2)"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[3] <> "! r(t+dt)"},
          {Fint[3] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz) = &"},
          {Fint[4] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz) + dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "Call RemoveGridDrifts(Fields)"},
          {Fint[1]},
          {Fint[1] <> "Forces = 0.0D0"},
          {Fint[1] <> "do iz = 1, NGridz"},
          {Fint[1] <> "do iy = 1, NGridy"},
          {Fint[1] <> "do ix = 1, NGridx"},
          {Fint[2] <> "Forces(:,:) = Forces(:,:) &"},
          {Fint[3] <> "+ GetForcesEpsDisp(ix,iy,iz,Fields0,e0ij0) &"},
          {Fint[3] <> "+ GetForcesEps(1,1,1,Fields0,e0ij0)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "Forces(:,:) = Forces(:,:)/(NGridx*NGridy*NGridz*mass(4)*mpme)"},
          {Fint[1] <> "de0ijdt(:,:) = de0ijdt(:,:) + 0.5d0*DeltaT/7.464D0*(eta2eij(Forces(:,4))-gm*de0ijdt(:,:))"},
          {Fint[1] <> "e0ij(:,:) = e0ij(:,:) + de0ijdt(:,:)*DeltaT/7.464D0"},
          {Fint[1]}}],
       {{Fint[1] <> "Call RemoveGridDrifts(Fields)"},
        {Fint[1] <> "Call RemoveGridDrifts(dFieldsdt)"},
        {Fint[1] <> "Call NoseHooverUpdate(gm, T0, dFieldsdt, de0ijdt)"},
        {Fint[1]}},
       If[OptionValue["AllSites"], 
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[2] <> "Forces = GetEwaldForces(Fields) &"},
          {Fint[3] <> "+ GetForces(Fields, e0ij)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "Forces = GetForces(Fields, e0ij)"},
          {Fint[1] <> "end if"},
          {Fint[1] <> "Forces(:,1,:,:,:) = Forces(:,1,:,:,:)/mass(1)/mpme"},
          {Fint[1] <> "Forces(:,2,:,:,:) = Forces(:,2,:,:,:)/mass(2)/mpme"},
          {Fint[1] <> "Forces(:,3,:,:,:) = Forces(:,3,:,:,:)/mass(3)/mpme"},
          {Fint[1] <> "Forces(:,4,:,:,:) = Forces(:,4,:,:,:)/mass(4)/mpme"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[1] <> "do iz = 1, NGridz"},
          {Fint[1] <> "do iy = 1, NGridy"},
          {Fint[1] <> "do ix = 1, NGridx"}
          {Fint[2] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[3] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField,ix,iy,iz))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"}},
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[2] <> "do iz = 1, NGridz"},
          {Fint[2] <> "do iy = 1, NGridy"},
          {Fint[2] <> "do ix = 1, NGridx"},
          {Fint[3] <> "Forces = GetEwaldForces(ix,iy,iz,Fields) &"},
          {Fint[4] <> "+ GetForces(ix,iy,iz,Fields,e0ij)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "else"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[2] <> "do iz = 1, NGridz"},
          {Fint[2] <> "do iy = 1, NGridy"},
          {Fint[2] <> "do ix = 1, NGridx"},
          {Fint[3] <> "Forces = GetForces(ix,iy,iz,Fields,e0ij)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "Forces = 0.0D0"},
          {Fint[1] <> "do iz = 1, NGridz"},
          {Fint[1] <> "do iy = 1, NGridy"},
          {Fint[1] <> "do ix = 1, NGridx"},
          {Fint[2] <> "Forces(:,:) = Forces(:,:) &"},
          {Fint[3] <> "+ GetForcesEpsDisp(ix,iy,iz,Fields,e0ij) &"},
          {Fint[3] <> "GetForcesEps(1,1,1,Fields,e0ij)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "Forces(:,:) = Forces(:,:)/(NGridx*NGridy*NGridz*mass(4)*mpme)"},
          {Fint[1] <> "de0ijdt(:,:) = (de0ijdt(:,:) + 0.5d0*DeltaT/7.464D0*eta2eij(Forces(:,4)))/(1.0D0+0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[1]}}],
       {{"End Subroutine TikTok"}}
    ];
  Return[Fout]
]

FortranLatticePTSwap[] := Module[{Fint, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = {{"Subroutine GetPTSwapMap(TempList, EtotList, NumReplicas, Replicas)"},
          {Fint[1]},
          {Fint[1] <> "Use LINVARIANT"},
          {Fint[1] <> "Use Constants"},
          {Fint[1] <> "Use Inputs"},
          {Fint[1]},
          {Fint[1] <> "Implicit none"},
          {Fint[1] <> "Integer, Intent(in)    :: NumReplicas"},
          {Fint[1] <> "Real*8,  Intent(inout) :: TempList(NumReplicas)"},
          {Fint[1] <> "Integer, Intent(inout) :: Replicas(NumReplicas,5)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: EtotList(NumReplicas)"},
          {Fint[1] <> "Integer                :: ireplica, TempReplica(3)"},
          {Fint[1] <> "Real*8                 :: dene, ProbTest, TempEtot"},
          {Fint[1] <> "Real*8                 :: rdum, AccProb"},
          {Fint[1]},
          {Fint[1] <> "do ireplica = 1, NumReplicas"},
          {Fint[2] <> "Replicas(ireplica,1) = ireplica"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "do ireplica = 1, NumReplicas - 1"},
          {Fint[2] <> "dene = Hartree/k_bolt_ev*(1/TempList(ireplica+1)-1/TempList(ireplica))*(EtotList(ireplica+1)-EtotList(ireplica))"},
          {Fint[2] <> "AccProb = Min(1.0d0, Exp(dene))"},
          {Fint[2] <> "Call random_number(ProbTest)"},
          {Fint[2] <> "if(ProbTest .lt. AccProb) then"},
          {Fint[3] <> "TempReplica(:) = Replicas(ireplica,1:3) "},
          {Fint[3] <> "Replicas(ireplica,1:3) = Replicas(ireplica+1,1:3)"},
          {Fint[3] <> "Replicas(ireplica+1,1:3) = TempReplica(:)"},
          {Fint[3] <> "TempEtot = EtotList(ireplica)"},
          {Fint[3] <> "EtotList(ireplica) = EtotList(ireplica+1)"},
          {Fint[3] <> "EtotList(ireplica+1) = TempEtot"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "Replicas(1,3) = 1"},
          {Fint[1] <> "Replicas(NumReplicas,3) = -1"},
          {Fint[1] <> "do ireplica = 1, NumReplicas"},
          {Fint[2] <> "if(ireplica.ne.Replicas(ireplica,1)) then"},
          {Fint[3] <> "if(Replicas(ireplica,3).eq.1) then"},
          {Fint[4] <> "Replicas(ireplica,4) = Replicas(ireplica,4) + 1"},
          {Fint[3] <> "else if(Replicas(ireplica,3).eq.-1) then"},
          {Fint[4] <> "Replicas(ireplica,5) = Replicas(ireplica,5) + 1"},
          {Fint[3] <> "end if"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {"End Subroutine GetPTSwapMap"},
          {Fint[1]},
          {Fint[1]},
          {"Subroutine PTSwap(TempList, Fields, EwaldField, e0ij, dFieldsdt, de0ijdt, gm, NumReplicas, Replicas, ireplica, istep)"},
          {Fint[1]},
          {Fint[1] <> "Use LINVARIANT"},
          {Fint[1] <> "Use Constants"},
          {Fint[1] <> "Use Inputs"},
          {Fint[1] <> "use mpi"},
          {Fint[1] <> ""},
          {Fint[1] <> "Implicit none"},
          {Fint[1] <> "Real*8,  Intent(inout) :: TempList(NumReplicas)"},
          {Fint[1] <> "Integer, Intent(inout) :: Replicas(NumReplicas,5)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: dFieldsdt(FieldDim, NumField, NGridx, NGridy, NGridz)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: EwaldField(FieldDim, NumField, NGridx, NGridy, NGridz)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: Real*8,  Intent(inout) :: gm"},
          {Fint[1] <> "Integer, Intent(in)    :: NumReplicas, ireplica"},
          {Fint[1] <> "Integer                :: i, istep, DimFields1D, IERROR"},
          {Fint[1]},
          {Fint[1] <> "Real*8   :: MPI_EWALDFIELD_1D(NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_EWALDFIELD_1D_Recv(NumReplicas*NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_FIELD_1D(NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_FIELD_1D_Recv(NumReplicas*NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_DFIELDDT_1D(NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_DFIELDDT_1D_Recv(NumReplicas*NGridx*NGridy*NGridz*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_ETA(6)"},
          {Fint[1] <> "Real*8   :: MPI_ETA_Recv(NumReplicas*6)"},
          {Fint[1] <> "Real*8   :: MPI_DETADT(6)"},
          {Fint[1] <> "Real*8   :: MPI_DETADT_Recv(NumReplicas*6)"},
          {Fint[1] <> "Real*8   :: Real*8   :: MPI_GM"},
          {Fint[1] <> "Real*8   :: Real*8   :: MPI_GM_Recv(NumReplicas)"},
          {Fint[1] <> "Real*8   :: EtotRecv(NumReplicas)"},
          {Fint[1] <> "Real*8   :: Etot, Tk"},
          {Fint[1]},
          {Fint[1] <> "DimFields1D = NGridx*NGridy*NGridz*NumField*FieldDim"},
          {Fint[1]},
          {Fint[1] <> "if(CoolingSteps.eq.0)then"},
          {Fint[2] <> "Etot = GetEtot(Fields, e0ij)"},
          {Fint[2] <> "Tk = Thermometer(dFieldsdt, de0ijdt)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "if(ireplica.eq.istep) then"},
          {Fint[3] <> "Etot = (ireplica-1)*1.0E6 "},
          {Fint[2] <> "elseif(ireplica.eq.istep-1)then"},
          {Fint[3] <> "Etot = (ireplica+1)*1.0E6"},
          {Fint[2] <> "else"},
          {Fint[3] <> "Etot = ireplica*1.0E6"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "MPI_ETA = eij2eta(e0ij)"},
          {Fint[1] <> "MPI_FIELD_1D = FieldsTo1D(Fields)"},
          {Fint[1] <> "MPI_EWALDFIELD_1D = FieldsTo1D(EwaldField)"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!MPI_DETADT = eij2eta(de0ijdt)"},
          {Fint[2] <> "!MPI_DFIELDDT_1D = FieldsTo1D(dFieldsdt)"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {Fint[1] <> "if(mod(istep,TapeRate).eq.0) then"},
          {Fint[2] <> "do i = 1, NumReplicas"},
          {Fint[3] <> "if((i == ireplica).and.(trim(Solver).eq.\"PTMC\")) then"},
          {Fint[4] <> "write(*,*) i, \"@\", istep, \": \", TempList(i), \"(K)\", \"    \",\"Etot: \", Etot"},
          {Fint[3] <> "else if((i == ireplica).and.(trim(Solver).eq.\"PTMD\")) then"},
          {Fint[4] <> "write(*,'(I5,A1,I10,F10.4,A1,F10.4,A12,F10.6)') i, \"@\", istep, Tk, \"/\", TempList(i), \"(K)  Epot: \", Etot"},
          {Fint[3] <> "end if"},
          {Fint[3] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_GATHER(Etot,1,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "EtotRecv,1,MPI_DOUBLE_PRECISION,0,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_ETA,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_ETA_Recv,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_FIELD_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_FIELD_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_EWALDFIELD_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_EWALDFIELD_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_DETADT,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_DETADT_Recv,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_DFIELDDT_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_DFIELDDT_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_GM,0,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_GM_Recv,0,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[1]},
          {Fint[1] <> "if(ireplica.eq.1) then"},
          {Fint[2] <> "call GetPTSwapMap(TempList,EtotRecv,NumReplicas,Replicas)"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_BCAST(Replicas(:,1), NumReplicas, MPI_INTEGER, 0, MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "call MPI_BCAST(TempList, NumReplicas, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "e0ij=eta2eij(MPI_ETA_Recv(1+Replicas(ireplica,1)*6-6:&"},
          {Fint[2] <> "Replicas(ireplica,1)*6))"},
          {Fint[1] <> "Fields=FieldsToND(MPI_FIELD_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[2] <> "Replicas(ireplica,1)*DimFields1D))"},
          {Fint[1] <> "EwaldField=FieldsToND(MPI_EWALDFIELD_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[2] <> "1+Replicas(ireplica,1)*DimFields1D))"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!de0ijdt=eta2eij(MPI_DETADT_Recv(1+Replicas(ireplica,1)*6-6:&"},
          {Fint[3] <> "!Replicas(ireplica,1)*6))"},
          {Fint[2] <> "!dFieldsdt=FieldsToND(MPI_DFIELDDT_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[3] <> "!Replicas(ireplica,1)*DimFields1D))"},
          {Fint[2] <> "!gm=MPI_GM_Recv(Replicas(ireplica,1))"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {"End Subroutine PTSwap"}};
  Return[Fout]
]

FortranLatticeMCStep[OptionsPattern[{"EwaldField"->True, "SwapAll"->False}]] := Module[{Fint, n, Fout, EwaldFieldArg, EwaldFieldBlock},
  Fint[n_] := StringRepeat["  ", n];
  EwaldFieldArg = If[OptionValue["EwaldField"], "EwaldField,", ""];
  EwaldFieldBlock = If[OptionValue["EwaldField"], {{Fint[6] <> "if (DipoleQ.and.(idelta.lt.NumField)) then"},
                                                   {Fint[7] <> "Call UpdateEwaldField(ix, iy, iz, EwaldField, idelta, dfield)"},
                                                   {Fint[6] <> "end if"}}, {}];
  Fout = Join[{
    {"Subroutine MCMCStep(imc, Fields, EwaldField, e0ij, T, udamp, etadamp, dene)"},
    {Fint[1]},
    {Fint[1] <> "Use LINVARIANT"},
    {Fint[1] <> "Use Constants"},
    {Fint[1] <> "Use Inputs"},
    {Fint[1]},
    {Fint[1] <> "Implicit none"},
    {Fint[1] <> "Real*8,  Intent(in)    :: T"},
    {Fint[1] <> "Integer, Intent(inout) :: imc"},
    {Fint[1] <> "Real*8,  Intent(inout) :: udamp(NumField), etadamp, dene"},
    {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"}, 
    {Fint[1] <> "Real*8,  Intent(inout) :: EwaldField(FieldDim, NumField, NGridx, NGridy, NGridz)"},
    {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"}, 
    {Fint[1] <> "Integer                :: i, j, idelta, ix, iy, iz"}, 
    {Fint[1] <> "Integer                :: idum, acceptedu(NumField), acceptedeta"}}, 
   {{Fint[1] <> "Real*8                 :: dfield(FieldDim), deta(6), DeltaE"}}, 
   {{Fint[1] <> "Real*8                 :: ProbTest"},
    {Fint[1] <> "Real*8                 :: rdum, AccProb"},
    {Fint[1]},
    {Fint[1] <> "acceptedu = 0"},
    {Fint[1] <> "acceptedeta = 0"},
    {Fint[1] <> "DeltaE = 0.0D0"},
    {Fint[1] <> "dene = 0.0D0"},
    {Fint[1] <> "dfield = 0.0D0"},
    {Fint[1]},
    {Fint[1] <> "do iz = 1, NGridz"},
    {Fint[2] <> "do iy = 1, NGridy"},
    {Fint[3] <> "do ix = 1, NGridx"},
    {Fint[4] <> "do idelta = 1, NumField"},
    {Fint[5]},
    {Fint[5] <> "Call random_number(dfield)"},
    {Fint[5] <> "dfield = udamp(idelta)*(dfield - 0.5D0)"},
    {Fint[5]},
    {Fint[5] <> "DeltaE = GetDeltaH(ix, iy, iz, Fields, e0ij, idelta, dfield)"},
    {Fint[5] <> "if (DipoleQ.and.(idelta.lt.NumField)) then"},
    {Fint[6] <> "DeltaE = DeltaE &"},
    {Fint[7] <> "+ GetDeltaHEwald(ix, iy, iz, " <> If[OptionValue["EwaldField"], "EwaldField, ", "Fields, "] <> "idelta, dfield)"},
    {Fint[5] <> "end if"},
    {Fint[1]},
    {Fint[5] <> "AccProb = Min(1.0d0, Exp(-1.0d0*DeltaE/T/k_bolt_ev*Hartree))"},
    {Fint[5] <> "Call random_number(ProbTest)"},
    {Fint[5] <> "if(ProbTest .lt. AccProb) then"},
    {Fint[6] <> "acceptedu(idelta) = acceptedu(idelta) + 1"},
    {Fint[6] <> "dene = dene + DeltaE"},
    {Fint[6] <> "do i = 1, FieldDimList(idelta)"},
    {Fint[7] <> "Fields(i,idelta,ix,iy,iz) = Fields(i,idelta,ix,iy,iz) + dfield(i)"},
    {Fint[6] <> "end do"}},
  EwaldFieldBlock,
  {{Fint[5] <> "end if"},
    {Fint[1]},
    {Fint[4] <> "end do"},
    {Fint[3] <> "end do"},
    {Fint[2] <> "end do"},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "Call RemoveGridDrifts(Fields)"},
    {Fint[1]},
    {Fint[1] <> "do idum = 1, 2*NGridz+1"},
    {Fint[2] <> "Call random_number(deta)"},
    {Fint[2] <> "deta = etadamp*(deta - 0.5D0)"},
    {Fint[2] <> "DeltaE = 0.0D0"},
    {Fint[2] <> "do iz = 1, NGridz"},
    {Fint[3] <> "do iy = 1, NGridy"},
    {Fint[4] <> "do ix = 1, NGridx"},
    {Fint[5] <> "!DeltaE = DeltaE + GetDeltaH(ix, iy, iz, Fields, e0ij, NumField+1, deta)"},
    {Fint[5] <> "DeltaE = DeltaE &"},
    {Fint[6] <> "+ GetDeltaHEpsDisp(ix, iy, iz, Fields, e0ij, NumField+1, deta)"},
    {Fint[4] <> "end do"},
    {Fint[3] <> "end do"},
    {Fint[2] <> "end do"},
    {Fint[2] <> "DeltaE = DeltaE + NGridx*NGridy*NGridz*GetDeltaHEps(1, 1, 1, Fields, e0ij, NumField+1, deta)"},
    {Fint[2]},
    {Fint[2] <> "AccProb = Min(1.0d0, Exp(-1.0d0*DeltaE/T/k_bolt_ev*Hartree))"},
    {Fint[2] <> "Call random_number(ProbTest)"},
    {Fint[2] <> "if(ProbTest .lt. AccProb) then"},
    {Fint[3] <> "acceptedeta = acceptedeta + 1"},
    {Fint[3] <> "dene = dene + DeltaE"},
    {Fint[3] <> "e0ij(1,1) = e0ij(1,1) + deta(1)"},
    {Fint[3] <> "e0ij(2,2) = e0ij(2,2) + deta(2)"},
    {Fint[3] <> "e0ij(3,3) = e0ij(3,3) + deta(3)"},
    {Fint[3] <> "e0ij(2,3) = e0ij(2,3) + deta(4)"},
    {Fint[3] <> "e0ij(1,3) = e0ij(1,3) + deta(5)"},
    {Fint[3] <> "e0ij(1,2) = e0ij(1,2) + deta(6)"},
    {Fint[2] <> "end if"},
    {Fint[2]},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "do idelta = 1, NumField"},
    {Fint[2] <> "rdum = real(acceptedu(idelta))/real(NGridx*NGridy*NGridz)"},
    {Fint[2] <> "if(rdum .gt. AcceptRatio) then"},
    {Fint[3] <> "udamp(idelta) = DampRatio*udamp(idelta)"},
    {Fint[2] <> "else"},
    {Fint[3] <> "udamp(idelta) = udamp(idelta)/DampRatio"},
    {Fint[2] <> "end if"},
    {Fint[2] <> "udamp(idelta) = Min(udamp(idelta), 3.0d0)"},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "if(mod(imc,1).eq.0) then"},
    {Fint[2] <> "rdum = real(acceptedeta)/real(2*NGridz+1)"},
    {Fint[2] <> "if(rdum .gt. AcceptRatio) then"},
    {Fint[3] <> "etadamp = DampRatio*etadamp"},
    {Fint[2] <> "else"},
    {Fint[3] <> "etadamp = etadamp/DampRatio"},
    {Fint[2] <> "end if"},
    {Fint[2] <> "etadamp = Min(etadamp, 3.0d0)"},
    {Fint[1] <> "end if"},
    {Fint[1]},
    {"End Subroutine MCMCStep"}}];
  Return[Fout]
] 

FortranGetInitConfig[] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = {
  {"Subroutine GetInitConfig(Fields, e0ij, inittype, FileCode)"},
  {Fint[1] <> "use Parameters"},
  {Fint[1] <> "use Inputs"},
  {Fint[1] <> "use Fileparser"},
  {Fint[1]},
  {Fint[1] <> "Implicit none"},
  {Fint[1] <> "character(20)                 :: keyword"},
  {Fint[1] <> "character(50)                 :: filename"},
  {Fint[1] <> "character(40), intent(inout)  :: inittype"},
  {Fint[1] <> "character(10), intent(in)     :: FileCode"},
  {Fint[1] <> "real*8,        intent(inout)  :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
  {Fint[1] <> "real*8,        intent(inout)  :: e0ij(3,3)"},
  {Fint[1] <> "real*8                        :: eta(6)"},
  {Fint[1] <> "real*8                        :: rand"},
  {Fint[1] <> "integer                       :: i, j, ix, iy, iz"},
  {Fint[1] <> "logical                       :: file_exists"},
  {Fint[1] <> " "},
  {Fint[1]},
  {Fint[1] <> "filename = trim(Solver)//\".out/\"//trim(inittype)//\"-\"//trim(FileCode)//\".dat\""},
  {Fint[1] <> "call caps2small(inittype)"},
  {Fint[1] <> "keyword=trim(inittype)"},
  {Fint[1] <> "      "},
  {Fint[1] <> "SELECT CASE (keyword)"},
  {Fint[2] <> "CASE (\"random\")"},
  {Fint[3] <> "do iz = 1, NGridz"},
  {Fint[4] <> "do iy = 1, NGridy"},
  {Fint[5] <> "do ix = 1, NGridx"},
  {Fint[6] <> "do i = 1, NumField"},
  {Fint[7] <> "do j = 1, FieldDimList(i)"},
  {Fint[8] <> "Call random_number(rand)"},
  {Fint[8] <> "Fields(j,i,ix,iy,iz) = (rand-0.5d0)/1.0d1"},
  {Fint[8] <> "Fields(j,i,ix,iy,iz) = rand-0.5d0"},
  {Fint[7] <> "end do"},
  {Fint[6] <> "end do"},
  {Fint[5] <> "end do"},
  {Fint[4] <> "end do"},
  {Fint[3] <> "end do"},
  {Fint[3] <> "do i = 1, 6"},
  {Fint[3] <> "Call random_number(rand)"},
  {Fint[4] <> "eta(i) = (rand-0.50d0)/1.0d3"},
  {Fint[3] <> "end do"},
  {Fint[3] <> "e0ij = eta2eij(eta)"},
  {Fint[2] <> "CASE (\"zero\")"},
  {Fint[3] <> "Fields = 0.0d0"},
  {Fint[3] <> "e0ij = 0.0d0"},
  {Fint[2] <> "CASE (\"uniform\")"},
  {Fint[3] <> "e0ij = 1.0D-3"},
  {Fint[3] <> "Fields = 1.0D-1"},
  {Fint[2] <> "CASE DEFAULT"},
  {Fint[3] <> "INQUIRE(FILE=filename, EXIST=file_exists)"},
  {Fint[3] <> "if (file_exists .eqv. .False.) then"},
  {Fint[4] <> "write(*,*) \"Init not implemented yet!\""},
  {Fint[4] <> "call abort"},
  {Fint[3] <> "else"},
  {Fint[4] <> "write(*,*) \"Init from file: \", filename"},
  {Fint[4] <> "call InitFromFile(filename, Fields, e0ij)"},
  {Fint[3] <> "end if"},
  {Fint[2] <> "END SELECT"},
  {Fint[1] <> "  "},
  {"End Subroutine GetInitConfig"}};
  Return[Fout]
]

FortranEwaldMatrix[] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = {
  {"Subroutine EwaldMatrix(latt)"},
  {Fint[1]},
  {Fint[1] <> "Use Parameters"},
  {Fint[1] <> "Use Constants"},
  {Fint[1] <> "Use LINVARIANT"},
  {Fint[1] <> "Use Inputs"},
  {Fint[1]},
  {Fint[1] <> "Implicit none"},
  {Fint[1] <> "Real*8, Intent(in) :: latt(3,3)"},
  {Fint[1] <> "Real*8             :: dpij(3,3,NGridx,NGridy,NGridz), dum(3,3), supercell(3,3), reclatt(3,3), am(3)"},
  {Fint[1] <> "Real*8             :: pi2, celvol, eta, eta4, gcut, gcut2, dum0"},
  {Fint[1] <> "Real*8             :: gx, gy, gz, g2, fact, tol, c, residue"},
  {Fint[1]},
  {Fint[1] <> "Integer            :: i, j, mg1, mg2, mg3, ix, iy, iz, ig1, ig2, ig3, rx, ry, rz"},
  {Fint[1]},
  {Fint[1] <> "Logical            :: origin"},
  {Fint[1]},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!"},
  {Fint[1] <> "! some constants !"},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!"},
  {Fint[1]},
  {Fint[1] <> "pi2 = pi*2.0d0"},
  {Fint[1]},
  {Fint[1] <> "tol = 1.0d-12"},
  {Fint[1] <> "eta = sqrt(-log(tol))"},
  {Fint[1] <> "gcut = 2.0*eta**2"},
  {Fint[1] <> "gcut2 = gcut**2"},
  {Fint[1] <> "eta4 = 1.0d0/(4*eta**2)"},
  {Fint[1]},
  {Fint[1] <> "supercell(:,1) = latt(:,1)*NGridx"},
  {Fint[1] <> "supercell(:,2) = latt(:,2)*NGridy"},
  {Fint[1] <> "supercell(:,3) = latt(:,3)*NGridz"},
  {Fint[1]},
  {Fint[1] <> "call reclat(supercell,reclatt,1)"},
  {Fint[1] <> "celvol = Cell2Volume(supercell)"},
  {Fint[1]},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"},
  {Fint[1] <> "! Estimate number of reciprocal lattice vectors to use !"},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"},
  {Fint[1]},
  {Fint[1] <> "do i = 1, 3"},
  {Fint[2] <> "am(i) = 0.d0"},
  {Fint[2] <> "do j = 1, 3"},
  {Fint[3] <> "am(i) = am(i) + supercell(j,i)**2"},
  {Fint[2] <> "enddo"},
  {Fint[2] <> "am(i) = sqrt(am(i))"},
  {Fint[1] <> "enddo"},
  {Fint[1]},
  {Fint[1] <> "mg1 = int(gcut*am(1)/pi2) + 1"},
  {Fint[1] <> "mg2 = int(gcut*am(2)/pi2) + 1"},
  {Fint[1] <> "mg3 = int(gcut*am(3)/pi2) + 1"},
  {Fint[1]},
  {Fint[1] <> "write(6,*) 'Simulation name: ', NameSim"},
  {Fint[1] <> "write(6,*) 'Simulation cell volume:', celvol"},
  {Fint[1] <> "write(6,*) 'Simulation Grid:', NGridx, NGridy, NGridz"},
  {Fint[1] <> "write(6,*) 'Gcut: ', gcut, 'mg1,mg2,mg3: ', mg1,mg2,mg3"},
  {Fint[1] <> "write(6,*) 'Tol: ', tol"},
  {Fint[1]},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"},
  {Fint[1] <> "! Begin the calculation of dpij matrix !"},
  {Fint[1] <> "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"},
  {Fint[1]},
  {Fint[1] <> "do ix = 1, NGridx"},
  {Fint[2] <> "do iy = 1, NGridy"},
  {Fint[3] <> "do iz = 1, NGridz"},
  {Fint[3]},
  {Fint[4] <> "do i = 1, 3"},
  {Fint[5] <> "do j = 1, 3"},
  {Fint[6] <> "dum(i,j) = 0.0d0"},
  {Fint[5] <> "end do"},
  {Fint[4] <> "end do"},
  {Fint[4]},
  {Fint[4] <> "rx = ix - 1"},
  {Fint[4] <> "ry = iy - 1"},
  {Fint[4] <> "rz = iz - 1"},
  {Fint[4]},
  {Fint[4] <> "origin = (rx.eq.0) .and. (ry.eq.0) .and. (rz.eq.0)"},
  {Fint[4]},
  {Fint[4] <> "!"},
  {Fint[4] <> "!The term for -G gives the same contribution as the one for G,"},
  {Fint[4] <> "!so we only sum over half the ig1 range and multiply by 2 (exclude"},
  {Fint[4] <> "!ig1=0)"},
  {Fint[4] <> "!"},
  {Fint[4] <> "!Since we are really computing the \"dipole field\", "},
  {Fint[4] <> "!not the total dipole energy, we need another factor of 2:"},
  {Fint[4] <> "!"},
  {Fint[4] <> "!Energy = Sum_ij{ Q_ij u_i u_j}, "},
  {Fint[4] <> "!Field_k= Partial Energy/Partial u_k = 2*Sum_i{Q_ik u_i} "},
  {Fint[4] <> "!"},
  {Fint[4]},
  {Fint[4] <> "c = 8.0d0*pi/celvol"},
  {Fint[4] <> "residue = eta**3*(4.0d0/(3.0d0*sqrt(pi)))"},
  {Fint[4]},
  {Fint[5] <> "do ig1 = 0, mg1"},
  {Fint[6] <> "do ig2 = -mg2, mg2"},
  {Fint[7] <> "gx = ig1*reclatt(1,1) + ig2*reclatt(1,2) "},
  {Fint[7] <> "gy = ig1*reclatt(2,1) + ig2*reclatt(2,2) "},
  {Fint[7] <> "do ig3 = -mg3, mg3"},
  {Fint[7]},
  {Fint[8] <> "gz = ig3*reclatt(3,3)"},
  {Fint[8] <> "g2 = gx**2 + gy**2 + gz**2"},
  {Fint[8]},
  {Fint[8] <> "if(g2.lt.gcut2.and.g2.gt.1.0d-8) then"},
  {Fint[9] <> "fact = 1.0d0"},
  {Fint[9] <> "if(ig1.eq.0) fact = 0.50d0"},
  {Fint[10] <> "dum0 = fact*cos(gx*rx+gy*ry+gz*rz)*exp(-g2*eta4)/g2"},
  {Fint[10] <> "dum(1,1) = dum(1,1) + dum0*gx**2"},
  {Fint[10] <> "dum(2,2) = dum(2,2) + dum0*gy**2"},
  {Fint[10] <> "dum(3,3) = dum(3,3) + dum0*gz**2"},
  {Fint[10] <> "dum(2,3) = dum(2,3) + dum0*gz*gy"},
  {Fint[10] <> "dum(1,3) = dum(1,3) + dum0*gx*gz"},
  {Fint[10] <> "dum(1,2) = dum(1,2) + dum0*gx*gy"},
  {Fint[10]},
  {Fint[10] <> "dum(3,2) = dum(2,3)"},
  {Fint[10] <> "dum(3,1) = dum(1,3)"},
  {Fint[10] <> "dum(2,1) = dum(1,2)"},
  {Fint[9] <> "end if"},
  {Fint[8] <> "end do ! ig3=-mg3,mg3"},
  {Fint[7] <> "end do ! ig2=-mg2,mg2"},
  {Fint[6] <> "end do ! ig1=0,mg1"},
  {Fint[6]},
  {Fint[6] <> "do i = 1, 3"},
  {Fint[7] <> "do j = 1, 3"},
  {Fint[8] <> "dpij(i, j, ix, iy, iz) = dum(i,j)*c"},
  {Fint[7] <> "end do"},
  {Fint[6] <> "end do"},
  {Fint[6] <> "if (origin) then"},
  {Fint[7] <> "dpij(1, 1, ix, iy, iz) = dpij(1, 1, ix, iy, iz) - residue"},
  {Fint[7] <> "dpij(2, 2, ix, iy, iz) = dpij(2, 2, ix, iy, iz) - residue"},
  {Fint[7] <> "dpij(3, 3, ix, iy, iz) = dpij(3, 3, ix, iy, iz) - residue"},
  {Fint[6] <> "endif"},
  {Fint[5] <> "end do ! ix"},
  {Fint[4] <> "end do ! iy"},
  {Fint[3] <> "end do ! iz"},
  {Fint[3]},
  {Fint[3] <> "open(1, file='EwaldMat.dat', form='unformatted', status='unknown')"},
  {Fint[3] <> "write(1) NameSim, NGridx, NGridy, NGridz"},
  {Fint[3] <> "write(1) (((((dpij(j, i, ix,iy,iz),j=1,3),i=1,3),ix=1,NGridx),iy=1,NGridy),iz=1,NGridz)"},
  {Fint[3] <> "close(1)"},
  {Fint[1]},
  {Fint[3] <> "open(2, file='EwaldMat.mma.dat', form='formatted', status='unknown')"},
  {Fint[3] <> "write(2, '(3e25.14)') (((((dpij(j, i, ix,iy,iz),j=1,3),i=1,3),ix=1,NGridx),iy=1,NGridy),iz=1,NGridz)"},
  {Fint[3] <> "close(2)"},
  {Fint[1]},
  {"End Subroutine EwaldMatrix"}};
  Return[Fout]
]

FortranEOnSiteEwald[OptionsPattern[{}]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = {{"Function GetEOnSiteEwald(ix, iy, iz, Fields) Result(ene)"},
          {Fint[1]},
          {Fint[1] <> "Use omp_lib"},
          {Fint[1] <> "Use Parameters"},
          {Fint[1] <> "Implicit none"},
          {Fint[1] <> "Integer, Intent(in) :: ix, iy, iz"},
          {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
          {Fint[1] <> "Integer             :: i, j, jx, jy, jz, x, y, z, jfield, ifield"},
          {Fint[1] <> "Real*8              :: ene, ThreadEne"},
          {Fint[1]},
          {Fint[1] <> "ene = 0.0d0"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(jfield,x,y,z,ThreadEne)"},
          {Fint[2] <> "ThreadEne = 0.0d0"},
          {Fint[2]},
          {Fint[2] <> "!$OMP    DO COLLAPSE(1)"},
          {Fint[3] <> "do jz = 1, NGridz"},
          {Fint[3] <> "do jy = 1, NGridy"},
          {Fint[3] <> "do jx = 1, NGridx"},
          {Fint[3] <> "do jfield = 1, NumField ! delete jfield to decouple two fields"},
          {Fint[3] <> "do ifield = 1, NumField"},
          {Fint[3] <> "do j = 1, FieldDimList(jfield) ! jfield -> ifield"},
          {Fint[3] <> "do i = 1, FieldDimList(ifield)"},
          {Fint[4] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
          {Fint[4] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
          {Fint[4] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
          {Fint[4] <> "! jfield -> ifield"},
          {Fint[4] <> "ThreadEne = ThreadEne &"},
          {Fint[5] <> "+ 0.5*FieldCharge(ifield)*FieldCharge(jfield)*Fields(i,ifield,ix,iy,iz)*EwaldMat(i,j,x,y,z)*Fields(j,jfield,jx,jy,jz)"},
          {Fint[3] <> "end do ! j"},
          {Fint[3] <> "end do ! j"},
          {Fint[3] <> "end do ! i"},
          {Fint[3] <> "end do ! jz"},
          {Fint[3] <> "end do ! jy"},
          {Fint[3] <> "end do ! jx"},
          {Fint[3] <> "end do"},
          {Fint[2] <> "!$OMP    END DO"},
          {Fint[2]},
          {Fint[2] <> "!$OMP CRITICAL"},
          {Fint[3] <> "ene = ene + ThreadEne"},
          {Fint[2] <> "!$OMP END CRITICAL"},
          {Fint[2]},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1]},
          {Fint[1] <> "do jfield = 1, NumField - 1 ! delete jfield to decouple two fields"},
          {Fint[2] <> "do ifield = 1, NumField - 1"},
          {Fint[3] <> "do j = 1, FieldDimList(jfield) ! jfield -> ifield"},
          {Fint[4] <> "do i = 1, FieldDimList(ifield)"},
          {Fint[4] <> "! jfield -> ifield"},
          {Fint[5] <> "ene = ene &"},
          {Fint[6] <> "+ 0.5*FieldCharge(ifield)*FieldCharge(jfield)*Fields(i,ifield,ix,iy,iz)*EwaldMat(i,j,1,1,1)*Fields(j,jfield,ix,iy,iz)"},
          {Fint[4] <> "end do ! j"},
          {Fint[3] <> "end do ! i"},
          {Fint[2] <> "end do ! "},
          {Fint[1] <> "end do ! "},
          {Fint[1]},
          {"End Function GetEOnSiteEwald"}};
  Return[Fout]
]

FortranDeltaHEwald[OptionsPattern[{"EwaldField"->True, "SwapAll" -> False}]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = If[OptionValue["EwaldField"],
           Join[
            {{"Function GetDeltaHEwald(x0, y0, z0, EwaldField" <> If[OptionValue["SwapAll"], "", ", idelta"] <> ", delta) Result(ene)"},
             {Fint[1]},
             {Fint[1] <> "Use Parameters"},
             {Fint[1] <> "Implicit none"},
             {Fint[1] <> "Integer, Intent(in) :: x0, y0, z0" <> If[OptionValue["SwapAll"], "", ", idelta"]},
             {Fint[1] <> "Real*8,  Intent(in) :: EwaldField(FieldDim, NumField, NGridx, NGridy, NGridz)"}},
            {{Fint[1] <> "Real*8,  Intent(in) :: delta(FieldDimList(idelta))"}},
            {{Fint[1] <> "Integer             :: i, j, ifield, jfield"},
             {Fint[1] <> "Real*8              :: ene, ThreadEne"},
             {Fint[1]},
             {Fint[1] <> "ene = 0.0d0"},
             {Fint[1]}},
            If[OptionValue["SwapAll"], {{Fint[1] <> "do ifield = 1, NumField - 1"},
                                        {Fint[2] <> "do i = 1, FieldDimList(ifield)"},
                                        {Fint[3] <> "ene = ene + delta(i)*EwaldField(i,ifield,x0,y0,z0)"},
                                        {Fint[2] <> "end do ! i"},
                                        {Fint[1] <> "end do ! i"}},
                                       {{Fint[1] <> "do i = 1, FieldDimList(idelta)"},
                                        {Fint[2] <> "ene = ene + delta(i)*EwaldField(i,idelta,x0,y0,z0)"},
                                        {Fint[1] <> "end do ! i"}}],
            If[OptionValue["SwapAll"], {{Fint[1]},
                                        {Fint[1] <> "do ifield = 1, NumField - 1"},
                                        {Fint[2] <> "do jfield = 1, NumField - 1"},
                                        {Fint[3] <> "do i = 1, FieldDimList(ifield)"},
                                        {Fint[4] <> "do j = 1, FieldDimList(jfield)"},
                                        {Fint[5] <> "ene = ene + 0.5*FieldCharge(ifield)*FieldCharge(jfield)*delta(i)*EwaldMat(j,i,1,1,1)*delta(j)"},
                                        {Fint[4] <> "end do ! j"},
                                        {Fint[3] <> "end do ! j"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[1] <> "end do ! i"}},
                                       {{Fint[1]},
                                        {Fint[1] <> "do i = 1, FieldDimList(idelta)"},
                                        {Fint[2] <> "do j = 1, FieldDimList(idelta)"},
                                        {Fint[3] <> "ene = ene + 0.5*FieldCharge(idelta)**2*delta(i)*EwaldMat(j,i,1,1,1)*delta(j)"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[1] <> "end do ! i"}}],
            {{Fint[1]},
             {"End Function GetDeltaHEwald"}}],
           Join[
            {{"Function GetDeltaHEwald(ix, iy, iz, Fields" <> If[OptionValue["SwapAll"], "", ", idelta"] <> "delta) Result(ene)"},
             {Fint[1]},
             {Fint[1] <> "Use omp_lib"},
             {Fint[1] <> "Use Parameters"},
             {Fint[1] <> "Implicit none"},
             {Fint[1] <> "Integer, Intent(in) :: ix, iy, iz" <> If[OptionValue["SwapAll"], "", ", idelta"]},
             {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"}},
            {{Fint[1] <> "Real*8,  Intent(in) :: delta(FieldDimList(idelta))"}},
            {{Fint[1] <> "Integer             :: i, j, jx, jy, jz, x, y, z, ifield, jfield"},
             {Fint[1] <> "Real*8              :: ene, ThreadEne"},
             {Fint[1]},
             {Fint[1] <> "INTEGER             :: ThreadId"},
             {Fint[1]},
             {Fint[1] <> "ene = 0.0d0"},
             {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(jfield,x,y,z,ThreadEne)"},
             {Fint[2] <> "ThreadEne = 0.0d0"},
             {Fint[2]}},
            If[OptionValue["SwapAll"], {{Fint[2] <> "!$OMP    DO COLLAPSE(1)"},
                                        {Fint[3] <> "do jz = 1, NGridz"},
                                        {Fint[4] <> "do jy = 1, NGridy"},
                                        {Fint[5] <> "do jx = 1, NGridx"},
                                        {Fint[6] <> "do jfield = 1, NumField - 1"},
                                        {Fint[7] <> "do ifield = 1, NumField - 1"},
                                        {Fint[8] <> "do i = 1, FieldDimList(ifield)"},
                                        {Fint[9] <> "do j = 1, FieldDimList(jfield)"},
                                        {Fint[10] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
                                        {Fint[10] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
                                        {Fint[10] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
                                        {Fint[10] <> "ThreadEne = ThreadEne &"},
                                        {Fint[11] <> "+ FieldCharge(ifield)*FieldCharge(jfield)*delta(i)*EwaldMat(j,i,x,y,z)*Fields(j,jfield,jx,jy,jz)"},
                                        {Fint[9] <> "end do ! j"},
                                        {Fint[8] <> "end do ! i"},
                                        {Fint[7] <> "end do ! jz"},
                                        {Fint[6] <> "end do ! jy"},
                                        {Fint[5] <> "end do ! jx"},
                                        {Fint[4] <> "end do ! ifield"},
                                        {Fint[3] <> "end do ! ifield"},
                                        {Fint[2] <> "!$OMP    END DO"},
                                        {Fint[2]},
                                        {Fint[2] <> "!$OMP CRITICAL"},
                                        {Fint[3] <> "ene = ene + ThreadEne"},
                                        {Fint[2] <> "!$OMP END CRITICAL"},
                                        {Fint[1]},
                                        {Fint[1] <> "!$OMP    END PARALLEL"}},
                                       {{Fint[2] <> "!$OMP    DO COLLAPSE(1)"},
                                        {Fint[3] <> "do jz = 1, NGridz"},
                                        {Fint[4] <> "do jy = 1, NGridy"},
                                        {Fint[5] <> "do jx = 1, NGridx"},
                                        {Fint[6] <> "do jfield = 1, NumField - 1"},
                                        {Fint[7] <> "do i = 1, FieldDimList(idelta)"},
                                        {Fint[8] <> "do j = 1, FieldDimList(jfield)"},
                                        {Fint[9] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
                                        {Fint[9] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
                                        {Fint[9] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
                                        {Fint[9] <> "ThreadEne = ThreadEne &"},
                                        {Fint[10] <> "+ FieldCharge(idelta)*FieldCharge(jfield)*delta(i)*EwaldMat(j,i,x,y,z)*Fields(j,jfield,jx,jy,jz)"},
                                        {Fint[8] <> "end do ! j"},
                                        {Fint[7] <> "end do ! i"},
                                        {Fint[6] <> "end do ! jz"},
                                        {Fint[5] <> "end do ! jy"},
                                        {Fint[4] <> "end do ! jx"},
                                        {Fint[3] <> "end do ! ifield"},
                                        {Fint[2] <> "!$OMP    END DO"},
                                        {Fint[2]}}],
            {{Fint[2] <> "!$OMP CRITICAL"},
             {Fint[3] <> "ene = ene + ThreadEne"},
             {Fint[2] <> "!$OMP END CRITICAL"},
             {Fint[1]},
             {Fint[1] <> "!$OMP    END PARALLEL"}},
            {{Fint[1]}},
            If[OptionValue["SwapAll"], {{Fint[1] <> "do ifield = 1, NumField - 1"},
                                        {Fint[2] <> "do jfield = 1, NumField - 1"},
                                        {Fint[1] <> "do i = 1, FieldDimList(ifield)"},
                                        {Fint[2] <> "do j = 1, FieldDimList(jfield)"},
                                        {Fint[3] <> "ene = ene + 0.5*FieldCharge(ifield)*FieldCharge(jfield)*delta(i)*EwaldMat(j,i,1,1,1)*delta(j)"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[1] <> "end do ! i"}},
                                       {{Fint[1] <> "do i = 1, 3"},
                                        {Fint[2] <> "do j = 1, 3"},
                                        {Fint[3] <> "ene = ene + 0.5*FieldCharge(idelta)*FieldCharge(idelta)*delta(i)*EwaldMat(j,i,1,1,1)*delta(j)"},
                                        {Fint[2] <> "end do ! j"},
                                        {Fint[1] <> "end do ! i"}}],
            {{Fint[1]},
             {"End Function GetDeltaHEwald"}}]];
  Return[Fout]
]

FortranGetEwaldField[OptionsPattern[]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = Join[{{"Subroutine GetEwaldField(Fields, EwaldField)"},
   {Fint[1] <> "Use omp_lib"},
   {Fint[1] <> "use Parameters"},
   {Fint[1] <> "use Inputs"},
   {Fint[1] <> "use Fileparser"},
   {Fint[1] <> ""},
   {Fint[1] <> "implicit none"},
   {Fint[1] <> "real*8,  intent(in)           :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
   {Fint[1] <> "real*8,  intent(inout)        :: EwaldField(FieldDim, NumField, NGridx, NGridy, NGridz)"},
   {Fint[1] <> "integer                       :: i, j, ifield, jfield, ix, iy, iz, jx, jy, jz, x, y, z"},
   {Fint[1]},
   {Fint[1] <> "EwaldField = 0.0D0"},
   {Fint[1]},
   {Fint[1] <> "!$OMP    PARALLEL  DEFAULT(SHARED) PRIVATE(x,y,z)"}, 
   {Fint[2] <> "do jz = 1, NGridz"},
   {Fint[2] <> "do jy = 1, NGridy"},
   {Fint[2] <> "do jx = 1, NGridx"},
   {Fint[2] <> "do jfield = 1, NumField - 1"},
   {Fint[2] <> "do j = 1, FieldDimList(jfield)"},
   {Fint[1] <> "!$OMP    DO COLLAPSE(1)"}, 
   {Fint[2] <> "do iz = 1, NGridz"},
   {Fint[2] <> "do iy = 1, NGridy"},
   {Fint[2] <> "do ix = 1, NGridx"},
   {Fint[2] <> "do ifield = 1, NumField - 1! delete to decouple two fields"},
   {Fint[2] <> "do i = 1, FieldDimList(ifield) ! ifield -> jfield"},
   {Fint[3] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
   {Fint[3] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
   {Fint[3] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
   {Fint[3] <> "! ifield -> jfield"},
   {Fint[3] <> "EwaldField(i,ifield,ix,iy,iz) = EwaldField(i,ifield,ix,iy,iz) &"},
   {Fint[4] <> "+ FieldCharge(jfield)*FieldCharge(ifield)*EwaldMat(j,i,x,y,z)*Fields(j,jfield,jx,jy,jz)"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[1] <> "!$OMP    END DO"}, 
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[2] <> "end do"},
   {Fint[1] <> "!$OMP    END PARALLEL"}, 
   {Fint[1]},
   {Fint[1]},
   {"End Subroutine GetEwaldField"}}];
  Return[Fout]
]

FortranUpdateEwaldField[OptionsPattern[{"SwapAll"->False}]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = Join[
    {{"Subroutine UpdateEwaldField(ix, iy, iz, EwaldField" <> If[OptionValue["SwapAll"], "", ", idelta"] <> ", delta)"},
     {Fint[1] <> "Use omp_lib"},
     {Fint[1] <> "use Parameters"},
     {Fint[1] <> "use Inputs"},
     {Fint[1] <> "use Fileparser"},
     {Fint[1] <> ""},
     {Fint[1] <> "Implicit none"},
     {Fint[1] <> "integer, intent(in)     :: ix, iy, iz" <> If[OptionValue["SwapAll"], "", ", idelta"]},
     {Fint[1] <> "real*8,  intent(inout)  :: EwaldField(FieldDim, NumField, NGridx, NGridy, NGridz)"}},
    {{Fint[1] <> "real*8,  intent(in)     :: delta(FieldDimList(idelta))"}},
    {{Fint[1] <> "integer                 :: i, j, ifield, jfield, jx, jy, jz, x, y, z"},
     {Fint[1]}},
    If[OptionValue["SwapAll"], {{Fint[1] <> "!$OMP    PARALLEL  DEFAULT(SHARED) PRIVATE(x,y,z)"},
                                {Fint[2] <> "do ifield = 1, NumField - 1"},
                                {Fint[2] <> "do i = 1, FieldDimList(ifield)"},
                                {Fint[1] <> "!$OMP    DO COLLAPSE(1)"},
                                {Fint[2] <> "do jz = 1, NGridz"},
                                {Fint[2] <> "do jy = 1, NGridy"},
                                {Fint[2] <> "do jx = 1, NGridx"},
                                {Fint[2] <> "do jfield = 1, NumField - 1 ! delete to decouple two fields"},
                                {Fint[2] <> "do j = 1, FieldDimList(jfield) ! jfield -> idelta"},
                                {Fint[3] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
                                {Fint[3] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
                                {Fint[3] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
                                {Fint[3] <> "! jfield -> idelta"},
                                {Fint[3] <> "EwaldField(j,jfield,jx,jy,jz) = &"},
                                {Fint[3] <> "EwaldField(j,jfield,jx,jy,jz) + FieldCharge(jfield)*FieldCharge(ifield)*EwaldMat(j,i,x,y,z)*delta(i)"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[1] <> "!$OMP    END DO"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[1] <> "!$OMP    END PARALLEL"}},
                               {{Fint[1] <> "!$OMP    PARALLEL  DEFAULT(SHARED) PRIVATE(x,y,z)"},
                                {Fint[2] <> "do i = 1, FieldDimList(idelta)"},
                                {Fint[1] <> "!$OMP    DO COLLAPSE(1)"},
                                {Fint[2] <> "do jz = 1, NGridz"},
                                {Fint[2] <> "do jy = 1, NGridy"},
                                {Fint[2] <> "do jx = 1, NGridx"},
                                {Fint[2] <> "do jfield = 1, NumField - 1 ! delete to decouple two fields"},
                                {Fint[2] <> "do j = 1, FieldDimList(jfield) ! jfield -> idelta"},
                                {Fint[3] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"},
                                {Fint[3] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"},
                                {Fint[3] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"},
                                {Fint[3] <> "! jfield -> idelta"},
                                {Fint[3] <> "EwaldField(j,jfield,jx,jy,jz) = &"},
                                {Fint[3] <> "EwaldField(j,jfield,jx,jy,jz) + FieldCharge(jfield)*FieldCharge(idelta)*EwaldMat(j,i,x,y,z)*delta(i)"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[2] <> "end do"},
                                {Fint[1] <> "!$OMP    END DO"},
                                {Fint[2] <> "end do"},
                                {Fint[1] <> "!$OMP    END PARALLEL"}}],
    {{Fint[1]},
     {"End Subroutine UpdateEwaldField"}}];
  Return[Fout]]

FortranGetEwaldForces[OptionsPattern[{"AllSites" -> True}]] := Module[{Fint, n, Fout, func},
  Fint[n_] := StringRepeat["  ", n];
  func = If[OptionValue["AllSites"], {{"Function GetEwaldForces(Fields) Result(EwaldForce)"}}, {{"Function GetEwaldForces(ix, iy, iz, Fields) Result(EwaldForce)"}}];
  Fout = Join[
    func,
    If[OptionValue["AllSites"], {{Fint[1] <> "Use omp_lib"}}, {}],
    {{Fint[1] <> "use Parameters"},
     {Fint[1] <> "use Inputs"},
     {Fint[1] <> "use Fileparser"},
     {Fint[1] <> ""},
     {Fint[1] <> "implicit none"},
     {Fint[1] <> "real*8,  intent(in)           :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
     {Fint[1] <> If[OptionValue["AllSites"], "Integer                       :: ", "Integer, Intent(in)           :: "] <> "ix, iy, iz"},
     {Fint[1] <> "integer                       :: i, ifield"},
     {Fint[1] <> "integer                       :: j, jfield, jx, jy, jz"},
     {Fint[1] <> "integer                       :: x, y, z"}, 
     {Fint[1] <> "real*8                        :: EwaldForce" <> If[OptionValue["AllSites"], "(FieldDim, NumField, NGridx, NGridy, NGridz)", "(Max(FieldDim, 6), NumField+1)"]}, 
     {Fint[1] <> "real*8                        :: force"},
     {Fint[1]},
     {Fint[1] <> "EwaldForce = 0.0D0"},
     {Fint[1]}},
    If[OptionValue["AllSites"],
     {{Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(ix,iy,iz,ifield,i,x,y,z,force)"},
      {Fint[1] <> "do jz = 1, NGridz"},
      {Fint[2] <> "do jy = 1, NGridy"},
      {Fint[3] <> "do jx = 1, NGridx"},
      {Fint[4] <> "do jfield = 1, NumField - 1"},
      {Fint[5] <> "do j = 1, FieldDimList(jfield)"},
      {Fint[6] <> "!$OMP    DO COLLAPSE(1)"},
      {Fint[6] <> "do iz = 1, NGridz"},
      {Fint[6] <> "do iy = 1, NGridy"},
      {Fint[6] <> "do ix = 1, NGridx"},
      {Fint[6] <> "do ifield = 1, NumField ! delete to decouple two fields"},
      {Fint[6] <> "do i = 1, FieldDimList(ifield) ! ifield -> jfield"}},
     {{Fint[1] <> "do jz = 1, NGridz"},
      {Fint[1] <> "do jy = 1, NGridy"},
      {Fint[1] <> "do jx = 1, NGridx"},
      {Fint[1] <> "do jfield = 1, NumField - 1"},
      {Fint[1] <> "do j = 1, FieldDimList(jfield)"},
      {Fint[1] <> "do ifield = 1, NumField - 1! delete to decouple two fields"},
      {Fint[1] <> "do i = 1, FieldDimList(ifield) ! ifield -> jfield"}}],
    {{Fint[If[OptionValue["AllSites"], 7, 2]] <> "x = (jx-ix+1)-floor(real(jx-ix)/real(NGridx))*NGridx"}, 
     {Fint[If[OptionValue["AllSites"], 7, 2]] <> "y = (jy-iy+1)-floor(real(jy-iy)/real(NGridy))*NGridy"}, 
     {Fint[If[OptionValue["AllSites"], 7, 2]] <> "z = (jz-iz+1)-floor(real(jz-iz)/real(NGridz))*NGridz"}, 
     {Fint[If[OptionValue["AllSites"], 7, 2]] <> "! ifield -> jfield"}, 
     {Fint[If[OptionValue["AllSites"], 7, 2]] <> "force = FieldCharge(ifield)*FieldCharge(jfield)*EwaldMat(i,j,x,y,z)*Fields(j,jfield,jx,jy,jz)"}},
    If[OptionValue["AllSites"],
     {{Fint[7] <> "! ifield -> jfield"},
      {Fint[7] <> "EwaldForce(i, ifield, ix, iy, iz) = EwaldForce(i, ifield, ix, iy, iz) - force"}},
     {{Fint[2] <> "EwaldForce(i, ifield) = EwaldForce(i, ifield) - force"}}],
    If[OptionValue["AllSites"],
     {{Fint[6] <> "end do"},
      {Fint[6] <> "end do"},
      {Fint[6] <> "end do"},
      {Fint[6] <> "end do"},
      {Fint[6] <> "end do"},
      {Fint[6] <> "!$OMP    END DO"},
      {Fint[5] <> "end do"},
      {Fint[4] <> "end do"},
      {Fint[3] <> "end do"},
      {Fint[2] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "!$OMP    END PARALLEL"}},
     {{Fint[1] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "end do"},
      {Fint[1] <> "end do"}}],
    {{Fint[1]},
     {"End Function GetEwaldForces"}}];
  Return[Fout]
]

HeadTailDeltaH[FunctionName_?StringQ, ReturnVar_, nn_, OptionsPattern[{}]] := Module[{Fint, n, head, tail, res, reslist},
  Fint[n_] := StringRepeat["  ", n];
  {res, reslist} = Which[StringQ[ReturnVar], {ReturnVar, {ReturnVar}}, ListQ[ReturnVar] && Length[ReturnVar] == 2, {First[ReturnVar], ReturnVar[[2]]}, True, Print["ReturnVar either a string or a list with 2 elements"; Abort[]]];
  head = Join[{{"Function " <> FunctionName <> "(x0, y0, z0, Fields, e0ij, idelta, delta) Result(" <> res <> ")"},
               {Fint[1]},
               {Fint[1] <> "Implicit none"},
               {Fint[1] <> "Integer, Intent(in) :: x0, y0, z0, idelta"},
               {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
               {Fint[1] <> "Real*8,  Intent(in) :: delta(FieldDimList(idelta))"},
               {Fint[1] <> "Real*8,  Intent(in) :: e0ij(3,3)"},
               {Fint[1] <> "Real*8              :: eij(3,3), euij(3,3)"}},
              {Fint[1] <> "Real*8              :: " <> #} & /@ DeleteDuplicates[Join[{res}, reslist]],
              {{Fint[1]}},
              HopingCodeBlock[nn][[2]],
              {{Fint[1]}},
              HopingCodeBlock[nn][[3]],
              {{Fint[1]}},
              {Fint[1] <> # <> " = 0.0D0"} & /@ DeleteDuplicates[Join[{res}, reslist]],
              {{Fint[1] <> "euij = StrainFromu(x0, y0, z0, Fields)"},
               {Fint[1] <> "eij = e0ij + euij"},
               {Fint[1]}
              }
              ];
  tail = {{Fint[1]}, {"End Function " <> FunctionName}};
  Return[{head, tail}]
] 

HeadTailForces[FunctionName_?StringQ, ReturnVar_, nn_, OptionsPattern[{"AllSites" -> True}]] := 
 Module[{Fint, n, head, tail, res, reslist, func},
  Fint[n_] := StringRepeat["  ", n];
  {res, reslist} = Which[StringQ[ReturnVar], {ReturnVar, {ReturnVar}}, ListQ[ReturnVar] && Length[ReturnVar] == 2, {First[ReturnVar], ReturnVar[[2]]}, True, Print["ReturnVar either a string or a list with 2 elements"; Abort[]]];
  func = If[OptionValue["AllSites"], {{"Function " <> FunctionName <> "(Fields, e0ij) Result(" <> res <> ")"}}, {{"Function " <> FunctionName <> "(x0, y0, z0, Fields, e0ij) Result(" <> res <> ")"}}];
  head = Join[ 
      func,
      {{Fint[1]},
       {Fint[1] <> "use Parameters"},
       {Fint[1] <> "use Inputs"}},
      If[OptionValue["AllSites"], {{Fint[1] <> "Use omp_lib"}}, {}],
      {{Fint[1]},
       {Fint[1] <> "Implicit none"},
       {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"}, 
       {Fint[1] <> "Real*8,  Intent(in) :: e0ij(3,3)"},
       {Fint[1] <> If[OptionValue["AllSites"], "Integer             :: ", "Integer, Intent(in) :: "] <> "x0, y0, z0"},
       {Fint[1] <> "Real*8              :: eij(3,3), euij(3,3)"}},
       {Fint[1] <> "Real*8              :: " <> # <> If[OptionValue["AllSites"], "(FieldDim, NumField, NGridx, NGridy, NGridz)", "(Max(FieldDim, 6), NumField+1)"]} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[1]}},
      HopingCodeBlock[nn][[2]],
      {{Fint[1]}},
      If[OptionValue["AllSites"], 
         {{Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(" <> StringJoin[Riffle[Join[{"eij,euij,x0","y0","z0"},HopingCodeBlock[nn][[1]]], ","]] <> ")"}, 
          {Fint[1] <> "!$OMP    DO COLLAPSE(3)"},
          {Fint[1] <> "do x0 = 1, NGridz"},
          {Fint[1] <> "do y0 = 1, NGridy"},
          {Fint[1] <> "do z0 = 1, NGridx"}}, {}],
      {{Fint[2]}},
      {Fint[1] <> # <> " = 0.0D0"} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[2] <> "euij = StrainFromu(x0, y0, z0, Fields)"},
       {Fint[2] <> "eij = e0ij + euij"},
       {Fint[2]}},
      HopingCodeBlock[nn, "int" -> If[OptionValue["AllSites"], 2, 1]][[3]],
      {{Fint[1]}}];
  tail = Join[
    If[OptionValue["AllSites"], 
      {{Fint[1] <> "end do"},
       {Fint[1] <> "end do"},
       {Fint[1] <> "end do"},
       {Fint[1] <> "!$OMP    END DO"},
       {Fint[1] <> "!$OMP    END PARALLEL"}}, {}],
    If[ListQ[ReturnVar], {{Fint[1] <> res <> "=" <> StringJoin[Riffle[reslist, "+"]]}}, {}],
    {{Fint[1]},
     {"End Function " <> FunctionName}}];
  Return[{head, tail}]]

HeadTailHessianOnSite[FunctionName_?StringQ, ReturnVar_, nn_, OptionsPattern[{}]] :=
 Module[{Fint, n, head, tail, res, reslist, func},
  Fint[n_] := StringRepeat["  ", n];
  {res, reslist} = Which[StringQ[ReturnVar], {ReturnVar, {ReturnVar}}, ListQ[ReturnVar] && Length[ReturnVar] == 2, {First[ReturnVar], ReturnVar[[2]]}, True, Print["ReturnVar either a string or a list with 2 elements"; Abort[]]];
  func = {{"Function " <> FunctionName <> "(x0, y0, z0, Fields, e0ij) Result(" <> res <> ")"}};
  head = Join[
      func,
      {{Fint[1]},
       {Fint[1] <> "use Parameters"},
       {Fint[1] <> "use Inputs"}},
      {{Fint[1]},
       {Fint[1] <> "Implicit none"},
       {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
       {Fint[1] <> "Real*8,  Intent(in) :: e0ij(3,3)"},
       {Fint[1] <> "Integer, Intent(in) :: x0, y0, z0"},
       {Fint[1] <> "Real*8              :: eij(3,3), euij(3,3)"}},
      {Fint[1] <> "Real*8              :: " <> # <> "(OnSiteDim, OnSiteDim)"} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[1]}},
      HopingCodeBlock[nn][[2]],
      {{Fint[1]}},
      {Fint[1] <> # <> " = 0.0D0"} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[1] <> "euij = StrainFromu(x0, y0, z0, Fields)"},
       {Fint[1] <> "eij = e0ij + euij"},
       {Fint[1]}},
      HopingCodeBlock[nn, "int" -> 1][[3]],
      {{Fint[1]}}];
  tail = Join[
    If[ListQ[ReturnVar], {{Fint[1] <> res <> "=" <> StringJoin[Riffle[reslist, "+"]]}}, {}],
    {{Fint[1]},
     {"End Function " <> FunctionName}}];
  Return[{head, tail}]
]

HeadTailEOnSite[FunctionName_?StringQ, ReturnVar_, nn_, OptionsPattern[{"AllSites" -> True}]] := Module[{Fint, n, head, tail, res, reslist, func},
  Fint[n_] := StringRepeat["  ", n];
  {res, reslist} = Which[StringQ[ReturnVar], {ReturnVar, {ReturnVar}}, ListQ[ReturnVar] && Length[ReturnVar] == 2, {First[ReturnVar], ReturnVar[[2]]}, True, Print["ReturnVar either a string or a list with 2 elements"; Abort[]]];
  func = If[OptionValue["AllSites"], {{"Function " <> FunctionName <> "(Fields, e0ij) Result(" <> res <> ")"}}, {{"Function " <> FunctionName <> "(x0, y0, z0, Fields, e0ij) Result(" <> res <> ")"}}];
  head = Join[
      func,
      {{Fint[1]},
       {Fint[1] <> "use Parameters"},
       {Fint[1] <> "use Inputs"}},
      If[OptionValue["AllSites"], {{Fint[1] <> "Use omp_lib"}}, {}],
      {{Fint[1]},
       {Fint[1] <> "Implicit none"},
       {Fint[1] <> "Real*8,  Intent(in) :: Fields(FieldDim, NumField, NGridx, NGridy, NGridz)"},
       {Fint[1] <> "Real*8,  Intent(in) :: e0ij(3,3)"},
       {Fint[1] <> If[OptionValue["AllSites"], "Integer             :: ", "Integer, Intent(in) :: "] <> "x0, y0, z0"},
       {Fint[1] <> "Real*8              :: eij(3,3), euij(3,3)"}},
       {Fint[1] <> "Real*8              :: " <> # <> If[OptionValue["AllSites"], "(NGridx, NGridy, NGridz)", ""]} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[1]}},
      HopingCodeBlock[nn][[2]],
      {{Fint[1]}},
      {Fint[1] <> # <> " = 0.0D0"} & /@ DeleteDuplicates[Join[{res}, reslist]],
      {{Fint[1]}},
      If[OptionValue["AllSites"],
         {{Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(" <> StringJoin[Riffle[Join[{"eij,euij,x0","y0","z0"},HopingCodeBlock[nn][[1]]], ","]] <> ")"},
          {Fint[1] <> "!$OMP    DO COLLAPSE(3)"},
          {Fint[1] <> "do x0 = 1, NGridz"},
          {Fint[1] <> "do y0 = 1, NGridy"},
          {Fint[1] <> "do z0 = 1, NGridx"}}, {}],
      {{Fint[1]},
       {Fint[1] <> "euij = StrainFromu(x0, y0, z0, Fields)"},
       {Fint[1] <> "eij = e0ij + euij"},
       {Fint[1]}},
      HopingCodeBlock[nn, "int" -> If[OptionValue["AllSites"], 2, 1]][[3]],
      {{Fint[1]}}];
  tail = Join[
    If[OptionValue["AllSites"],
      {{Fint[1] <> "end do"},
       {Fint[1] <> "end do"},
       {Fint[1] <> "end do"},
       {Fint[1] <> "!$OMP    END DO"},
       {Fint[1] <> "!$OMP    END PARALLEL"}}, {}],
    If[ListQ[ReturnVar], {{Fint[1] <> res <> "=" <> StringJoin[Riffle[reslist, "+"]]}}, {}],
    {{Fint[1]},
     {"End Function " <> FunctionName}}];
  Return[{head, tail}]
]

WriteLatticeModelF90[F90dir_, FuncName_?StringQ, FuncType_?StringQ, InvariantList_?ListQ, MMAVars_, OptionsPattern[{"AllSites" -> False, "TylorOrder" -> 6}]] := Module[{FortranVar, FortranArrayVar, Invariants, HamList, ham, CoeffType, FortranVarList, ifield, i, inv, MMA, Fortran, f90, body, head, tail, CaseExprTable, var, ii},

  MMA2F90Vars = FortranVarSub[MMAVars];
  
  FortranVarList = FuncType <> # & /@ First[Transpose[InvariantList]];
  HamList = Table[{inv[[1]], Expand@If[ListQ[inv[[2]]], inv[[2]].(ToExpression["Coeff"<>inv[[1]]][#] & /@ Range[Length@inv[[2]]]), inv[[2]]]}, {inv, InvariantList}];
  Which[
  (* Forces *)
    FuncType == "Forces",
    Fortran = Flatten[
                Table[MMA =Flatten[Table[Table[
                        FortranArrayVar = If[OptionValue["AllSites"],
                                             FortranVarStr[FuncType<>ham[[1]], {ToString[i], ToString[ifield], "x0", "y0", "z0"}], 
                                             FortranVarStr[FuncType<>ham[[1]], {ToString[i], ToString[ifield]}]];
                        {FortranArrayVar, -D[Expand[ham[[2]]], MMAVars[[ifield, i]]]}, {i, Length@MMAVars[[ifield]]}], {ifield, Length@MMAVars}], 1];
                      {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];
    body = Flatten[FortranExprBlock[#1, #2, If[OptionValue["AllSites"], 2, 1]] & @@@ Fortran, 1];
    {head, tail} = HeadTailForces[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], 1, "AllSites" -> OptionValue["AllSites"]],
  (* DeltaH *)
    FuncType == "DeltaH",
    Fortran = Table[MMA = NOrderResponse[ham[[2]], #, OptionValue["TylorOrder"]] &/@ MMAVars;
                    Expr2Fortran[#, MMA2F90Vars] &/@ MMA, {ham, HamList}];
    CaseExprTable = Transpose[Table[FortranExprBlock[#1, #2[[i]], 2], {i, Length@#2}] & @@@ Transpose[{FortranVarList, Fortran}]];
    body = FortranCaseBlock["idelta", {ToString[#] & /@ Range[Length[First@Fortran]], Table[Join[Flatten[CaseExprTable[[i]], 1], {{"    " <> FuncType <> "=" <> StringJoin[Riffle[FortranVarList, "+"]]}, {"  "}}], {i, Length@CaseExprTable}]}\[Transpose], GetCaseDefaults[{{"write(*,*) \"mode out of range!\""}, {"call abort"}}, 1], 1];
    {head, tail} = HeadTailDeltaH[FuncName, {FuncType, FortranVarList}, 1], 
  (* EOnSite *)
    FuncType == "EOnSite",
    Fortran = Flatten[
                Table[FortranArrayVar = If[OptionValue["AllSites"], FortranVarStr[FuncType<>ham[[1]], {"x0", "y0", "z0"}], FuncType<>ham[[1]]];
                      MMA = {{FortranArrayVar, ham[[2]]}};
                      {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];
    body = Flatten[FortranExprBlock[#1, #2, If[OptionValue["AllSites"], 2, 1]] & @@@ Fortran, 1];
    {head, tail} = HeadTailEOnSite[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], 1, "AllSites" -> OptionValue["AllSites"]],
  (* HessianOnSite *)
    FuncType == "HessianOnSite",
    Fortran = Flatten[Table[MMA = Flatten[Table[FortranArrayVar = FortranVarStr[FuncType<>ham[[1]], {ToString[i], ToString[j]}];
                                    {FortranArrayVar, Expand@D[ham[[2]], MMAVars[[i]], MMAVars[[j]]]}, {i, Length@MMAVars}, {j, Length@MMAVars}], 1];
                            {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];
    body = Flatten[FortranExprBlock[#1, #2, 1] & @@@ Fortran, 1];
    {head, tail} = HeadTailHessianOnSite[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], 1]
];
  MMA2FORTRAN[F90dir <> "/" <> FuncName, Join[head, body, tail]];
]
(*-------------------------- Attributes ------------------------------*)

(*Attributes[]={Protected, ReadProtected}*)

End[]

EndPackage[]
