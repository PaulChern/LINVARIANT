BeginPackage["LINVARIANT`LatticeHamiltonianFortran`",{"LINVARIANT`Structure`","LINVARIANT`GroupTheory`","LINVARIANT`Fortran`", "LINVARIANT`MathematicaPlus`"}]

(*--------- Load, Save and Modify Crystal Structure Libraries ------------*)
FortranLatticeTikTok         ::usage "FortranLatticeTikTok[]"
FortranLatticeMCStep         ::usage "FortranLatticeMCStep[]"
FortranLatticePTSwap         ::usage "FortranLatticePTSwap[]"
WriteLatticeModelF90         ::usage "WriteLatticeModelF90[F90dir, FuncName, FuncType, InvariantList, MMAVars, MMA2F90Vars]"
(*--------- Plot and Manipulate Crystal Structures -------------------- ----------------*)

(*--------- Point and Space Group Information ---------------------------*)

(*--------------------------------------------------*)
(*-------------------------- Internal --------------*)
(*--------------------------------------------------*)

(*--------------------------- Options ----------------------------*)

(*--------------------------- external Modules -------------------*)

Begin["`Private`"]

(*--------------------------- Modules ----------------------------*)
FortranLatticeTikTok[OptionsPattern[{"AllSites"->True}]] := Module[{Fint, n, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = Join[
       {{"Subroutine TikTok(Fields, dFieldsdt, e0ij, de0ijdt, T0, gm)"},
        {Fint[1]},
        {Fint[1] <> "Use omp_lib"},
        {Fint[1] <> "Use LINVARIANT"},
        {Fint[1] <> "Use Constants"},
        {Fint[1] <> "Use Inputs"},
        {Fint[1]},
        {Fint[1] <> "Implicit none"},
        {Fint[1] <> "Real*8,  Intent(in)    :: T0"},
        {Fint[1] <> "Real*8,  Intent(inout) :: gm"},
        {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: dFieldsdt(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"},
        {Fint[1] <> "Real*8,  Intent(inout) :: de0ijdt(3,3)"},
        {Fint[1] <> "Real*8                 :: Fields0(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
        {Fint[1] <> "Real*8                 :: e0ij0(3,3)"}},
       If[OptionValue["AllSites"], {{Fint[1] <> "Real*8                 :: Forces(FieldDim,NumField,cgrid%n1,cgrid%n2,cgrid%n3)"}}, 
                                   {{Fint[1] <> "Real*8                 :: Forces(Max(FieldDim, 6),NumField+1)"}}],
       {{Fint[1] <> "Integer                :: i, ifield, fi, ix, iy, iz"},
        {Fint[1]},
        {Fint[1] <> "Fields0 = Fields"},
        {Fint[1] <> "e0ij0 = e0ij"},
        {Fint[1]}},
       If[OptionValue["AllSites"], 
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[2] <> "Forces = GetEwaldForces(Fields0) &"},
          {Fint[3] <> "+ GetForces(Fields0, e0ij0)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "Forces = GetForces(Fields0, e0ij0)"},
          {Fint[1] <> "end if"},
          {Fint[1] <> "Forces(:,1,:,:,:) = Forces(:,1,:,:,:)/mass(1)/mpme"},
          {Fint[1] <> "Forces(:,2,:,:,:) = Forces(:,2,:,:,:)/mass(2)/mpme"},
          {Fint[1] <> "Forces(:,3,:,:,:) = Forces(:,3,:,:,:)/mass(3)/mpme"},
          {Fint[1] <> "Forces(:,4,:,:,:) = Forces(:,4,:,:,:)/mass(4)/mpme"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1] <> "do iz = 1, cgrid%n3"},
          {Fint[1] <> "do iy = 1, cgrid%n2"},
          {Fint[1] <> "do ix = 1, cgrid%n1"},
          {Fint[2] <> "! v(t+dt/2)"},
          {Fint[2] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)=dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)&"},
          {Fint[3] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField,ix,iy,iz)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[2] <> "! r(t+dt)"},
          {Fint[2] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz)=&"},
          {Fint[3] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz)+dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"}},
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[2] <> "do iz = 1, cgrid%n3"},
          {Fint[2] <> "do iy = 1, cgrid%n2"},
          {Fint[2] <> "do ix = 1, cgrid%n1"},
          {Fint[3] <> "Forces = GetEwaldForces(ix,iy,iz,Fields0) &"},
          {Fint[4] <> "+ GetForces(ix,iy,iz,Fields0,e0ij0)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "! v(t+dt/2)"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[3] <> "! r(t+dt)"},
          {Fint[3] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz) = &"},
          {Fint[4] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz) + dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "else"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[2] <> "do iz = 1, cgrid%n3"},
          {Fint[2] <> "do iy = 1, cgrid%n2"},
          {Fint[2] <> "do ix = 1, cgrid%n1"},
          {Fint[3] <> "Forces = GetForces(ix,iy,iz,Fields0,e0ij0)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "! v(t+dt/2)"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*(Forces(1:FieldDim,1:NumField)-gm*dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz))"},
          {Fint[3] <> "! r(t+dt)"},
          {Fint[3] <> "Fields(1:FieldDim,1:NumField,ix,iy,iz) = &"},
          {Fint[4] <> "Fields0(1:FieldDim,1:NumField,ix,iy,iz) + dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz)*DeltaT/7.464D0"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "Call RemoveGridDrifts(Fields)"},
          {Fint[1]},
          {Fint[1] <> "Forces = 0.0D0"},
          {Fint[1] <> "do iz = 1, cgrid%n3"},
          {Fint[1] <> "do iy = 1, cgrid%n2"},
          {Fint[1] <> "do ix = 1, cgrid%n1"},
          {Fint[2] <> "Forces(:,:) = Forces(:,:) &"},
          {Fint[3] <> "+ GetForcesEpsDisp(ix,iy,iz,Fields0,e0ij0) &"},
          {Fint[3] <> "+ GetForcesEps(1,1,1,Fields0,e0ij0)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "Forces(:,:) = Forces(:,:)/(cgrid%n1*cgrid%n2*cgrid%n3*mass(4)*mpme)"},
          {Fint[1] <> "de0ijdt(:,:) = de0ijdt(:,:) + 0.5d0*DeltaT/7.464D0*(eta2eij(Forces(:,4))-gm*de0ijdt(:,:))"},
          {Fint[1] <> "e0ij(:,:) = e0ij(:,:) + de0ijdt(:,:)*DeltaT/7.464D0"},
          {Fint[1]}}],
       {{Fint[1] <> "Call RemoveGridDrifts(Fields)"},
        {Fint[1] <> "Call RemoveGridDrifts(dFieldsdt)"},
        {Fint[1] <> "if(NoseMass .eq. 0.0d0) then"},
        {Fint[2] <> "Call NoseHooverUpdate(gm, T0, dFieldsdt, de0ijdt)"},
        {Fint[1] <> "end if"},
        {Fint[1]}},
       If[OptionValue["AllSites"], 
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[2] <> "Forces = GetEwaldForces(Fields) &"},
          {Fint[3] <> "+ GetForces(Fields, e0ij)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "Forces = GetForces(Fields, e0ij)"},
          {Fint[1] <> "end if"},
          {Fint[1] <> "Forces(:,1,:,:,:) = Forces(:,1,:,:,:)/mass(1)/mpme"},
          {Fint[1] <> "Forces(:,2,:,:,:) = Forces(:,2,:,:,:)/mass(2)/mpme"},
          {Fint[1] <> "Forces(:,3,:,:,:) = Forces(:,3,:,:,:)/mass(3)/mpme"},
          {Fint[1] <> "Forces(:,4,:,:,:) = Forces(:,4,:,:,:)/mass(4)/mpme"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[1] <> "do iz = 1, cgrid%n3"},
          {Fint[1] <> "do iy = 1, cgrid%n2"},
          {Fint[1] <> "do ix = 1, cgrid%n1"}
          {Fint[2] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[3] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField,ix,iy,iz))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"}},
         {{Fint[1] <> "If(DipoleQ) then"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[2] <> "do iz = 1, cgrid%n3"},
          {Fint[2] <> "do iy = 1, cgrid%n2"},
          {Fint[2] <> "do ix = 1, cgrid%n1"},
          {Fint[3] <> "Forces = GetEwaldForces(ix,iy,iz,Fields) &"},
          {Fint[4] <> "+ GetForces(ix,iy,iz,Fields,e0ij)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "else"},
          {Fint[1] <> "!$OMP    PARALLEL DEFAULT(SHARED) PRIVATE(Forces)"},
          {Fint[1] <> "!$OMP    DO"},
          {Fint[1]},
          {Fint[2] <> "do iz = 1, cgrid%n3"},
          {Fint[2] <> "do iy = 1, cgrid%n2"},
          {Fint[2] <> "do ix = 1, cgrid%n1"},
          {Fint[3] <> "Forces = GetForces(ix,iy,iz,Fields,e0ij)"},
          {Fint[3] <> "Forces(:,1) = Forces(:,1)/mass(1)/mpme"},
          {Fint[3] <> "Forces(:,2) = Forces(:,2)/mass(2)/mpme"},
          {Fint[3] <> "Forces(:,3) = Forces(:,3)/mass(3)/mpme"},
          {Fint[3] <> "Forces(:,4) = Forces(:,4)/mass(4)/mpme"},
          {Fint[3] <> "dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) = (dFieldsdt(1:FieldDim,1:NumField,ix,iy,iz) &"},
          {Fint[4] <> "+ 0.5d0*DeltaT/7.464D0*Forces(1:FieldDim,1:NumField))/(1.0D0 + 0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[2] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "!$OMP    END DO"},
          {Fint[1] <> "!$OMP    END PARALLEL"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "Forces = 0.0D0"},
          {Fint[1] <> "do iz = 1, cgrid%n3"},
          {Fint[1] <> "do iy = 1, cgrid%n2"},
          {Fint[1] <> "do ix = 1, cgrid%n1"},
          {Fint[2] <> "Forces(:,:) = Forces(:,:) &"},
          {Fint[3] <> "+ GetForcesEpsDisp(ix,iy,iz,Fields,e0ij) &"},
          {Fint[3] <> "GetForcesEps(1,1,1,Fields,e0ij)"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "end do"},
          {Fint[1] <> "Forces(:,:) = Forces(:,:)/(cgrid%n1*cgrid%n2*cgrid%n3*mass(4)*mpme)"},
          {Fint[1] <> "de0ijdt(:,:) = (de0ijdt(:,:) + 0.5d0*DeltaT/7.464D0*eta2eij(Forces(:,4)))/(1.0D0+0.5D0*gm*DeltaT/7.464D0)"},
          {Fint[1]}}],
       {{"End Subroutine TikTok"}}
    ];
  Return[Fout]
]

FortranLatticePTSwap[] := Module[{Fint, Fout},
  Fint[n_] := StringRepeat["  ", n];
  Fout = {{"Subroutine GetPTSwapMap(TempList, EtotList, NumReplicas, Replicas)"},
          {Fint[1]},
          {Fint[1] <> "Use LINVARIANT"},
          {Fint[1] <> "Use Constants"},
          {Fint[1] <> "Use Inputs"},
          {Fint[1]},
          {Fint[1] <> "Implicit none"},
          {Fint[1] <> "Integer, Intent(in)    :: NumReplicas"},
          {Fint[1] <> "Real*8,  Intent(inout) :: TempList(NumReplicas)"},
          {Fint[1] <> "Integer, Intent(inout) :: Replicas(NumReplicas,5)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: EtotList(NumReplicas)"},
          {Fint[1] <> "Integer                :: ireplica, TempReplica(3)"},
          {Fint[1] <> "Real*8                 :: dene, ProbTest, TempEtot"},
          {Fint[1] <> "Real*8                 :: rdum, AccProb"},
          {Fint[1]},
          {Fint[1] <> "do ireplica = 1, NumReplicas"},
          {Fint[2] <> "Replicas(ireplica,1) = ireplica"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "do ireplica = 1, NumReplicas - 1"},
          {Fint[2] <> "dene = Hartree/k_bolt_ev*(1/TempList(ireplica+1)-1/TempList(ireplica))*(EtotList(ireplica+1)-EtotList(ireplica))"},
          {Fint[2] <> "AccProb = Min(1.0d0, Exp(dene))"},
          {Fint[2] <> "Call random_number(ProbTest)"},
          {Fint[2] <> "if(ProbTest .lt. AccProb) then"},
          {Fint[3] <> "TempReplica(:) = Replicas(ireplica,1:3) "},
          {Fint[3] <> "Replicas(ireplica,1:3) = Replicas(ireplica+1,1:3)"},
          {Fint[3] <> "Replicas(ireplica+1,1:3) = TempReplica(:)"},
          {Fint[3] <> "TempEtot = EtotList(ireplica)"},
          {Fint[3] <> "EtotList(ireplica) = EtotList(ireplica+1)"},
          {Fint[3] <> "EtotList(ireplica+1) = TempEtot"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {Fint[1] <> "Replicas(1,3) = 1"},
          {Fint[1] <> "Replicas(NumReplicas,3) = -1"},
          {Fint[1] <> "do ireplica = 1, NumReplicas"},
          {Fint[2] <> "if(ireplica.ne.Replicas(ireplica,1)) then"},
          {Fint[3] <> "if(Replicas(ireplica,3).eq.1) then"},
          {Fint[4] <> "Replicas(ireplica,4) = Replicas(ireplica,4) + 1"},
          {Fint[3] <> "else if(Replicas(ireplica,3).eq.-1) then"},
          {Fint[4] <> "Replicas(ireplica,5) = Replicas(ireplica,5) + 1"},
          {Fint[3] <> "end if"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end do"},
          {Fint[1]},
          {"End Subroutine GetPTSwapMap"},
          {Fint[1]},
          {Fint[1]},
          {"Subroutine PTSwap(TempList, Fields, EwaldField, e0ij, dFieldsdt, de0ijdt, gm, NumReplicas, Replicas, ireplica, istep)"},
          {Fint[1]},
          {Fint[1] <> "Use LINVARIANT"},
          {Fint[1] <> "Use Constants"},
          {Fint[1] <> "Use Inputs"},
          {Fint[1] <> "use mpi"},
          {Fint[1] <> ""},
          {Fint[1] <> "Implicit none"},
          {Fint[1] <> "Real*8,  Intent(inout) :: TempList(NumReplicas)"},
          {Fint[1] <> "Integer, Intent(inout) :: Replicas(NumReplicas,5)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: dFieldsdt(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: EwaldField(3, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"},
          {Fint[1] <> "Real*8,  Intent(inout) :: Real*8,  Intent(inout) :: gm"},
          {Fint[1] <> "Integer, Intent(in)    :: NumReplicas, ireplica"},
          {Fint[1] <> "Integer                :: i, istep, DimFields1D, IERROR"},
          {Fint[1]},
          {Fint[1] <> "Real*8   :: MPI_EWALDFIELD_1D(cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_EWALDFIELD_1D_Recv(NumReplicas*cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_FIELD_1D(cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_FIELD_1D_Recv(NumReplicas*cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_DFIELDDT_1D(cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_DFIELDDT_1D_Recv(NumReplicas*cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim)"},
          {Fint[1] <> "Real*8   :: MPI_ETA(6)"},
          {Fint[1] <> "Real*8   :: MPI_ETA_Recv(NumReplicas*6)"},
          {Fint[1] <> "Real*8   :: MPI_DETADT(6)"},
          {Fint[1] <> "Real*8   :: MPI_DETADT_Recv(NumReplicas*6)"},
          {Fint[1] <> "Real*8   :: Real*8   :: MPI_GM"},
          {Fint[1] <> "Real*8   :: Real*8   :: MPI_GM_Recv(NumReplicas)"},
          {Fint[1] <> "Real*8   :: EtotRecv(NumReplicas)"},
          {Fint[1] <> "Real*8   :: Etot, Tk"},
          {Fint[1]},
          {Fint[1] <> "DimFields1D = cgrid%n1*cgrid%n2*cgrid%n3*NumField*FieldDim"},
          {Fint[1]},
          {Fint[1] <> "if(CoolingSteps.eq.0)then"},
          {Fint[2] <> "Etot = GetEtot(Fields, e0ij)"},
          {Fint[2] <> "Tk = Thermometer(dFieldsdt, de0ijdt)"},
          {Fint[1] <> "else"},
          {Fint[2] <> "if(ireplica.eq.istep) then"},
          {Fint[3] <> "Etot = (ireplica-1)*1.0E6 "},
          {Fint[2] <> "elseif(ireplica.eq.istep-1)then"},
          {Fint[3] <> "Etot = (ireplica+1)*1.0E6"},
          {Fint[2] <> "else"},
          {Fint[3] <> "Etot = ireplica*1.0E6"},
          {Fint[2] <> "end if"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "MPI_ETA = eij2eta(e0ij)"},
          {Fint[1] <> "MPI_FIELD_1D = FieldsTo1D(Fields)"},
          {Fint[1] <> "MPI_EWALDFIELD_1D = FieldsTo1D(EwaldField)"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!MPI_DETADT = eij2eta(de0ijdt)"},
          {Fint[2] <> "!MPI_DFIELDDT_1D = FieldsTo1D(dFieldsdt)"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {Fint[1] <> "if(mod(istep,TapeRate).eq.0) then"},
          {Fint[2] <> "do i = 1, NumReplicas"},
          {Fint[3] <> "if((i == ireplica).and.(trim(Solver).eq.\"PTMC\")) then"},
          {Fint[4] <> "write(*,*) i, \"@\", istep, \": \", TempList(i), \"(K)\", \"    \",\"Etot: \", Etot"},
          {Fint[3] <> "else if((i == ireplica).and.(trim(Solver).eq.\"PTMD\")) then"},
          {Fint[4] <> "write(*,'(I5,A1,I10,F10.4,A1,F10.4,A12,F10.6)') i, \"@\", istep, Tk, \"/\", TempList(i), \"(K)  Epot: \", Etot"},
          {Fint[3] <> "end if"},
          {Fint[3] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[2] <> "end do"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_GATHER(Etot,1,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "EtotRecv,1,MPI_DOUBLE_PRECISION,0,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_ETA,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_ETA_Recv,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_FIELD_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_FIELD_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "call MPI_ALLGATHER(MPI_EWALDFIELD_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_EWALDFIELD_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[2] <> "MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_DETADT,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_DETADT_Recv,6,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_DFIELDDT_1D,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_DFIELDDT_1D_Recv,DimFields1D,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[2] <> "!call MPI_ALLGATHER(MPI_GM,0,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_GM_Recv,0,MPI_DOUBLE_PRECISION,&"},
          {Fint[3] <> "!MPI_COMM_WORLD,IERROR)"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[1]},
          {Fint[1] <> "if(ireplica.eq.1) then"},
          {Fint[2] <> "call GetPTSwapMap(TempList,EtotRecv,NumReplicas,Replicas)"},
          {Fint[1] <> "end if"},
          {Fint[1]},
          {Fint[1] <> "call MPI_BCAST(Replicas(:,1), NumReplicas, MPI_INTEGER, 0, MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "call MPI_BCAST(TempList, NumReplicas, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "call MPI_BARRIER(MPI_COMM_WORLD, IERROR)"},
          {Fint[1] <> "e0ij=eta2eij(MPI_ETA_Recv(1+Replicas(ireplica,1)*6-6:&"},
          {Fint[2] <> "Replicas(ireplica,1)*6))"},
          {Fint[1] <> "Fields=FieldsToND(MPI_FIELD_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[2] <> "Replicas(ireplica,1)*DimFields1D))"},
          {Fint[1] <> "EwaldField=FieldsToND(MPI_EWALDFIELD_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[2] <> "1+Replicas(ireplica,1)*DimFields1D))"},
          {Fint[1] <> "!if(trim(Solver).eq.\"PTMD\") then"},
          {Fint[2] <> "!de0ijdt=eta2eij(MPI_DETADT_Recv(1+Replicas(ireplica,1)*6-6:&"},
          {Fint[3] <> "!Replicas(ireplica,1)*6))"},
          {Fint[2] <> "!dFieldsdt=FieldsToND(MPI_DFIELDDT_1D_Recv(1+Replicas(ireplica,1)*DimFields1D-DimFields1D:&"},
          {Fint[3] <> "!Replicas(ireplica,1)*DimFields1D))"},
          {Fint[2] <> "!gm=MPI_GM_Recv(Replicas(ireplica,1))"},
          {Fint[1] <> "!end if"},
          {Fint[1]},
          {"End Subroutine PTSwap"}};
  Return[Fout]
]

FortranLatticeMCStep[OptionsPattern[{"EwaldField"->True, "SwapAll"->False}]] := Module[{Fint, n, Fout, EwaldFieldArg, EwaldFieldBlock},
  Fint[n_] := StringRepeat["  ", n];
  EwaldFieldArg = If[OptionValue["EwaldField"], "EwaldField,", ""];
  EwaldFieldBlock = If[OptionValue["EwaldField"], {{Fint[6] <> "if (DipoleQ.and.(idelta.lt.NumField)) then"},
                                                   {Fint[7] <> "Call UpdateEwaldField(ix, iy, iz, EwaldField, idelta, dfield)"},
                                                   {Fint[6] <> "end if"}}, {}];
  Fout = Join[{
    {"Subroutine MCMCStep(imc, Fields, EwaldField, e0ij, T, udamp, etadamp, dene)"},
    {Fint[1]},
    {Fint[1] <> "Use LINVARIANT"},
    {Fint[1] <> "Use Constants"},
    {Fint[1] <> "Use Inputs"},
    {Fint[1]},
    {Fint[1] <> "Implicit none"},
    {Fint[1] <> "Real*8,  Intent(in)    :: T"},
    {Fint[1] <> "Integer, Intent(inout) :: imc"},
    {Fint[1] <> "Real*8,  Intent(inout) :: udamp(NumField), etadamp, dene"},
    {Fint[1] <> "Real*8,  Intent(inout) :: Fields(FieldDim, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"}, 
    {Fint[1] <> "Real*8,  Intent(inout) :: EwaldField(3, NumField, cgrid%n1, cgrid%n2, cgrid%n3)"},
    {Fint[1] <> "Real*8,  Intent(inout) :: e0ij(3,3)"}, 
    {Fint[1] <> "Integer                :: i, j, idelta, ix, iy, iz"}, 
    {Fint[1] <> "Integer                :: idum, acceptedu(NumField), acceptedeta"}}, 
   {{Fint[1] <> "Real*8                 :: dfield(FieldDim), deta(6), DeltaE"}}, 
   {{Fint[1] <> "Real*8                 :: ProbTest"},
    {Fint[1] <> "Real*8                 :: rdum, AccProb"},
    {Fint[1]},
    {Fint[1] <> "acceptedu = 0"},
    {Fint[1] <> "acceptedeta = 0"},
    {Fint[1] <> "DeltaE = 0.0D0"},
    {Fint[1] <> "dene = 0.0D0"},
    {Fint[1] <> "dfield = 0.0D0"},
    {Fint[1]},
    {Fint[1] <> "do iz = 1, cgrid%n3"},
    {Fint[2] <> "do iy = 1, cgrid%n2"},
    {Fint[3] <> "do ix = 1, cgrid%n1"},
    {Fint[4] <> "do idelta = 1, NumField"},
    {Fint[5]},
    {Fint[5] <> "Call random_number(dfield)"},
    {Fint[5] <> "dfield = udamp(idelta)*(dfield - 0.5D0)"},
    {Fint[5]},
    {Fint[5] <> "DeltaE = GetDeltaH(ix, iy, iz, Fields, e0ij, idelta, dfield)"},
    {Fint[5] <> "if (DipoleQ.and.(idelta.lt.NumField)) then"},
    {Fint[6] <> "DeltaE = DeltaE &"},
    {Fint[7] <> "+ GetDeltaHEwald(ix, iy, iz, " <> If[OptionValue["EwaldField"], "EwaldField, ", "Fields, "] <> "idelta, dfield)"},
    {Fint[5] <> "end if"},
    {Fint[1]},
    {Fint[5] <> "AccProb = Min(1.0d0, Exp(-1.0d0*DeltaE/T/k_bolt_ev*Hartree))"},
    {Fint[5] <> "Call random_number(ProbTest)"},
    {Fint[5] <> "if(ProbTest .lt. AccProb) then"},
    {Fint[6] <> "acceptedu(idelta) = acceptedu(idelta) + 1"},
    {Fint[6] <> "dene = dene + DeltaE"},
    {Fint[6] <> "do i = 1, FieldDim"},
    {Fint[7] <> "Fields(i,idelta,ix,iy,iz) = Fields(i,idelta,ix,iy,iz) + FieldBinary(i,idelta)*dfield(i)"},
    {Fint[6] <> "end do"}},
  EwaldFieldBlock,
  {{Fint[5] <> "end if"},
    {Fint[1]},
    {Fint[4] <> "end do"},
    {Fint[3] <> "end do"},
    {Fint[2] <> "end do"},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "Call RemoveGridDrifts(Fields)"},
    {Fint[1]},
    {Fint[1] <> "do idum = 1, 2*cgrid%n3+1"},
    {Fint[2] <> "Call random_number(deta)"},
    {Fint[2] <> "deta = etadamp*(deta - 0.5D0)"},
    {Fint[2] <> "DeltaE = 0.0D0"},
    {Fint[2] <> "do iz = 1, cgrid%n3"},
    {Fint[3] <> "do iy = 1, cgrid%n2"},
    {Fint[4] <> "do ix = 1, cgrid%n1"},
    {Fint[5] <> "!DeltaE = DeltaE + GetDeltaH(ix, iy, iz, Fields, e0ij, NumField+1, deta)"},
    {Fint[5] <> "DeltaE = DeltaE &"},
    {Fint[6] <> "+ GetDeltaHEpsDisp(ix, iy, iz, Fields, e0ij, NumField+1, deta)"},
    {Fint[4] <> "end do"},
    {Fint[3] <> "end do"},
    {Fint[2] <> "end do"},
    {Fint[2] <> "DeltaE = DeltaE + cgrid%n1*cgrid%n2*cgrid%n3*GetDeltaHEps(1, 1, 1, Fields, e0ij, NumField+1, deta)"},
    {Fint[2]},
    {Fint[2] <> "AccProb = Min(1.0d0, Exp(-1.0d0*DeltaE/T/k_bolt_ev*Hartree))"},
    {Fint[2] <> "Call random_number(ProbTest)"},
    {Fint[2] <> "if(ProbTest .lt. AccProb) then"},
    {Fint[3] <> "acceptedeta = acceptedeta + 1"},
    {Fint[3] <> "dene = dene + DeltaE"},
    {Fint[3] <> "e0ij(1,1) = e0ij(1,1) + deta(1)"},
    {Fint[3] <> "e0ij(2,2) = e0ij(2,2) + deta(2)"},
    {Fint[3] <> "e0ij(3,3) = e0ij(3,3) + deta(3)"},
    {Fint[3] <> "e0ij(2,3) = e0ij(2,3) + deta(4)"},
    {Fint[3] <> "e0ij(1,3) = e0ij(1,3) + deta(5)"},
    {Fint[3] <> "e0ij(1,2) = e0ij(1,2) + deta(6)"},
    {Fint[2] <> "end if"},
    {Fint[2]},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "do idelta = 1, NumField"},
    {Fint[2] <> "rdum = real(acceptedu(idelta))/real(cgrid%n1*cgrid%n2*cgrid%n3)"},
    {Fint[2] <> "if(rdum .gt. AcceptRatio) then"},
    {Fint[3] <> "udamp(idelta) = DampRatio*udamp(idelta)"},
    {Fint[2] <> "else"},
    {Fint[3] <> "udamp(idelta) = udamp(idelta)/DampRatio"},
    {Fint[2] <> "end if"},
    {Fint[2] <> "udamp(idelta) = Min(udamp(idelta), 3.0d0)"},
    {Fint[1] <> "end do"},
    {Fint[1]},
    {Fint[1] <> "if(mod(imc,1).eq.0) then"},
    {Fint[2] <> "rdum = real(acceptedeta)/real(2*cgrid%n3+1)"},
    {Fint[2] <> "if(rdum .gt. AcceptRatio) then"},
    {Fint[3] <> "etadamp = DampRatio*etadamp"},
    {Fint[2] <> "else"},
    {Fint[3] <> "etadamp = etadamp/DampRatio"},
    {Fint[2] <> "end if"},
    {Fint[2] <> "etadamp = Min(etadamp, 3.0d0)"},
    {Fint[1] <> "end if"},
    {Fint[1]},
    {"End Subroutine MCMCStep"}}];
  Return[Fout]
] 

WriteLatticeModelF90[F90dir_, FuncName_?StringQ, FuncType_?StringQ, InvariantList_?ListQ, MMAVars_, OptionsPattern[{"AllSites" -> False, "TylorOrder" -> 6}]] := Module[{FortranVar, FortranArrayVar, Invariants, HamList, ham, CoeffType, FortranVarList, ifield, i, inv, MMA, Fortran, f90, body, head, tail, CaseExprTable, var, ii, MMA2F90Vars, nn, ix, iy, iz, FortranVarLength, ExprFunc, ExprFuncBlock, CollectData},

  MMA2F90Vars = FortranVarSub[MMAVars];
  ExprFunc = {{}};
 
  FortranVarList = FuncType <> # & /@ First[Transpose[InvariantList]];
  HamList = Table[{inv[[1]], Expand@If[ListQ[inv[[2]]], inv[[2]].(ToExpression["Coeff"<>inv[[1]]][#] & /@ Range[Length@inv[[2]]]), inv[[2]]]}, {inv, InvariantList}];

  nn = Max@Abs@Append[Flatten[Cases[Variables[HamList], #] & /@ DeleteDuplicates[(Subscript[First[#], _, ix_, iy_, iz_] -> {ix, iy, iz}) & /@ Flatten[MMAVars[[1 ;; -2]]]]], 0];

  Which[
  (*Forces*)
    FuncType == "Forces", 
    Fortran = Flatten[
              Table[MMA = Flatten[Table[Table[FortranArrayVar = If[OptionValue["AllSites"], 
                                              FortranFuncArg[FuncType <> ham[[1]] <> ToString[i] <> ToString[ifield], {"x0", "y0", "z0"}], 
                                              FuncType <> ham[[1]] <> ToString[i] <> ToString[ifield]];
                         {FortranArrayVar, -D[Expand[ham[[2]]], MMAVars[[ifield, i]]]}, {i, Length@MMAVars[[ifield]]}], {ifield, Length@MMAVars}], 1];
                         {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];

    ExprFuncBlock = FortranExprFunc[#1 <> "(nexpr)", FuncType, #2, nn, 2, "AllSites" -> OptionValue["AllSites"]] & @@@ Fortran;
    ExprFunc = Flatten[Append[Flatten[#, 1], {"  "}] & /@ (Transpose[ExprFuncBlock][[2]]), 1];

    ii = 0;
    CollectData = Flatten[Table[Table[ii = ii + 1; 
                      Join[{{"    " <> FuncType <> #1 <> "(" <> ToString[i] <> "," <> ToString[ifield] <> ",:" <> ",:" <> ",:" <> ") = &"}}, 
                      FortranSumRiffle[Table[FuncType <> #1 <> ToString[i] <> ToString[ifield] <> "n" <> ToString[j], 
                      {j, Length[ExprFuncBlock[[ii, 2]]]}], 3, 4]], {i, Length@MMAVars[[ifield]]}], {ifield, Length@MMAVars}] & @@@ HamList, 3];

    body = Join[{#} & /@ Flatten[ExprFuncBlock\[Transpose][[1]]], {{" "}}, CollectData];
    FortranVar = {"Real*8", StringTrim[#], {"cgrid%n1", "cgrid%n2", "cgrid%n3"}} & /@ (StringSplit[Flatten[ExprFuncBlock\[Transpose][[1]]], "="]\[Transpose][[1]]);
    {head, tail} = HeadTailForces[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], nn, "ExprFunc" -> False, "AllSites" -> OptionValue["AllSites"], "variables" -> FortranVar],

  (* Variation *)
    FuncType == "Variation",
    Fortran = Table[(*MMA = NOrderResponse[ham[[2]], #, OptionValue["TylorOrder"]] &/@ MMAVars;*)
                    MMA = Table[ParallelMap[NOrderResponse[#, var, OptionValue["TylorOrder"]]&, ham[[2]], 
                                            Method -> Automatic, 
                                            DistributedContexts -> {"LINVARIANT`LatticeHamiltonianFortran`Private`"}], {var, MMAVars}];
                    Expr2Fortran[#, MMA2F90Vars] &/@ MMA, {ham, HamList}];

    CaseExprTable = Transpose[Table[FortranExprFunc[#1 <> ToString[i] <> "(nexpr)", FuncType, #2[[i]], nn, 2, "AllSites" -> OptionValue["AllSites"]], {i, Length@#2}] & @@@Transpose[{FortranVarList, Fortran}]];
    ExprFunc = Flatten[Flatten[Transpose[#][[2]], 2] & /@ CaseExprTable, 1];

    FortranVarLength = Table[Length[#[[1]]] & /@ (CaseExprTable\[Transpose][[i]]), {i, Length@FortranVarList}];
    FortranVar = Flatten[Table[Table[#1 <> ToString[i] <> "n" <> ToString[ii], {ii, #2[[i]]}], {i, Length[#2]}] & @@@ Transpose[{FortranVarList, FortranVarLength}]];
    body = FortranCaseBlock["idelta", {ToString[#] & /@ Range[Length[First@Fortran]], Table[Join[{#} &/@ Flatten[First@Transpose[CaseExprTable[[i]]], 1], {{"  "}, {"    " <> FuncType <> " = &"}}, FortranSumRiffle[StringSplit[Flatten[First@Transpose[CaseExprTable[[i]]], 1], "="]\[Transpose][[1]], 3, 4], {{"  "}}], {i, Length@CaseExprTable}]}\[Transpose], GetCaseDefaults[{{"write(*,*) \"mode out of range!\""}, {"call abort"}}, 1], 1];
    {head, tail} = HeadTailVariation[FuncName, {FuncType, FortranVar}, nn, "AllSites" -> OptionValue["AllSites"], "ExprFunc" -> False], 

    (*SiteEnergy*)
    FuncType == "SiteEnergy", 
    Fortran = Flatten[Table[FortranArrayVar = If[OptionValue["AllSites"], 
                                                 FortranFuncArg[FuncType <> ham[[1]], {"x0", "y0", "z0"}], 
                                                 FuncType <> ham[[1]]];
                            MMA = {{FortranArrayVar, ham[[2]]}};
                            {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];

    ExprFuncBlock = FortranExprFunc[#1 <> "(nexpr)", FuncType, #2, nn, 2, "AllSites" -> OptionValue["AllSites"]] & @@@ Fortran;
    ExprFunc = Flatten[Append[Flatten[#, 1], {"  "}] & /@ (Transpose[ExprFuncBlock][[2]]), 1];

    CollectData = Flatten[Table[
                    Join[{{If[OptionValue["AllSites"], 
                              "    " <> FuncType <> HamList[[i, 1]] <> " = &", 
                              "    " <> FuncType <> HamList[[i, 1]] <> " = &"]}}, 
                         FortranSumRiffle[Table[FuncType <> HamList[[i, 1]] <> "n" <> ToString[j], 
                    {j, Length[ExprFuncBlock[[i, 2]]]}], 3, 4]], {i, Length@HamList}], 1];

    body = Join[{#} & /@ Flatten[ExprFuncBlock\[Transpose][[1]]], {{" "}}, CollectData];
    FortranVar = {"Real*8", StringTrim[#]} & /@ (StringSplit[Flatten[ExprFuncBlock\[Transpose][[1]]], "="]\[Transpose][[1]]);

    {head, tail} = HeadTailSiteEnergy[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], nn, "ExprFunc" -> False, "AllSites" -> OptionValue["AllSites"], "variables" -> FortranVar],

  (* HessianOnSite *)
    FuncType == "SiteHessian",
    Fortran = Flatten[Table[MMA = Flatten[Table[FortranArrayVar = FortranFuncArg[FuncType<>ham[[1]], {ToString[i], ToString[j]}];
                                    {FortranArrayVar, Expand@D[ham[[2]], {MMAVars[[i]],1}, {MMAVars[[j]],1}]}, {i, Length@MMAVars}, {j, Length@MMAVars}], 1];
                            {#1, Expr2Fortran[#2, MMA2F90Vars]} & @@@ MMA, {ham, HamList}], 1];
    body = Flatten[FortranExprBlock[#1, #2, 1] & @@@ Fortran, 1];
    {head, tail} = HeadTailHessianOnSite[FuncName, If[Length@FortranVarList == 1, First@FortranVarList, {FuncType, FortranVarList}], nn]];
  MMA2FORTRAN[F90dir <> "/" <> FuncName, Join[head, body, tail]];
  Return[ExprFunc]
]
(*-------------------------- Attributes ------------------------------*)

(*Attributes[]={Protected, ReadProtected}*)

End[]

EndPackage[]
